\section{??}

논문 5절 Application to RSA-OAEP에는 다음과 같은 내용이 있다.

\begin{quote}
    \noindent
    thanks to the random self-reducibility of RSA, \textbf{the partial-domain
    one-wayness of RSA is equivalent to that of the whole RSA problem}, as soon
    as a constant fraction of the most significant bits (or the least
    significant bits) of the pre-image can be recovered.
    
    이는 RSA의 무작위 자기환원성 덕분인데, \textbf{RSA의 부분 영역 일방향성은
    전체 RSA 문제의 일방향성과 동등하며}, 이는 전상 이미지(pre-image)의 가장
    상위 비트(또는 가장 하위 비트)의 일정 비율을 복구할 수 있을 때 성립합니다.
\end{quote}

본 절에서는 RSA의 부분 영역 일방향성이 전체 RSA 문제의 일방향성과 동등함을 보인다.

\begin{memo}
    본 논문의 제목은 `RSA-OAEP is Secure under the RSA Assumption'이다. 이는
    RSA가 OW일 때, RSA-OAEP가 IND-CCA2 안전함을 말하는 제목이다. 그러나 논문의
    4절에서는 RSA가 PD-OW일 때를 가정하고 IND-CCA2 안전함을 보인다.

    만약 RSA가 OW일 때, RSA는 PD-OW도 만족한다면, OW, PD-OW, IND-CCA2로
    연결될 수 있다. 그러나 RSA가 OW일 때, PD-OW를 만족함은 자명하지 않다. (그
    역은 자명하다) 논문의 5절에서는 이에 대해 증명하여, OW와 PD-OW가 동등함을
    보인다. 그리고 증명하는데 사용하는 기법이 Random Self-Reducibility이다.
\end{memo}

\subsection{Random Self-Reducibility}

\begin{tcolorbox}
    여기서는 `Rajeev Motwani and Prabhakar Raghavan. Randomized Algorithms.
    Cambridge University Press, 1995'의 Section 14.4의 내용을 다룬다.
\end{tcolorbox}

임의의 알고리듬 $\cA$에 대해, 집합 $C(\cA)$를 다음과 같이 정의한다.
$$
    C(\cA) := \{ c \in \mathbb{Z}_n^* : \cA \text{ can compute $c^d \bmod n$, given that $\cA$ knows only $n$ and $e$} \}.
$$

\begin{theorem}
    (아마도 무작위성을 가지는) 다항 시간 알고리듬 $\cA$이 존재한다고 가정하자.
    이때 $|C(\cA)| \geq \epsilon |\mathbb{Z}^*_n|$를 만족하며, 여기서 $\epsilon >
    0$ 이다. 그러면 $C(\cB) = \mathbb{Z}^*_n$을 만족하는 LasVegas 알고리듬
    $\cB$가 존재하며, $\cB$의 기대 실행 시간은 $\log n$과 $1/\epsilon$에 대해
    다항식이다.
\end{theorem}

\begin{proof}
    임의의 $c \in \mathbb{Z}_n^*$를 고정하고, 알고리듬 $\cB$가 알고리듬 $\cA$을
    블랙박스로 사용하여 $c^d \bmod n$을 계산할 수 있음을 보이겠다. 알고리듬
    $\cB$는 다음과 같이 동작한다.
    \begin{itemize}
        \item 알고리듬 $\cB$는 무작위 원소 $r \in \mathbb{Z}_n^*$를 선택하고 $z = cr^e$를 계산한다. 
        \item 그런 다음 입력 $z$에 대해 알고리듬 $\cA$를 실행한다.
        \item $\cA$로부터 받은 값에 $r$의 곱셈 역원을 곱한다.
    \end{itemize}
    $z^d = c^d r^{ed} \equiv c^d r \pmod n$ 임을 주목하자. $\cB$는 $z^d$로부터
    $c^d$의 값을 쉽게 유추할 수 있다. 따라서, $\cA$가 $z$에 대해 성공하면 알고리듬
    $\cB$는 성공한다.

    우리는 $z$가 $\mathbb{Z}_n^*$ 위에서 균등하게 분포한다고 주장하며, 따라서 $z
    \in C(\cA)$일 확률은 최소한 $\epsilon$ 이상이다. 이 주장은 곱셈과 $e$ 제곱
    연산이 군 $\mathbb{Z}_n^*$에서 일대일 대응이면서 전사 함수(즉, 순열)라는
    관찰에서 따라온다. 따라서 무작위 $r$에 대해 $z = cr^e$ 역시
    $\mathbb{Z}_n^*$에서 균등하게 분포한다.

    $\cB$가 $\epsilon$의 확률로 성공하므로, 독립 반복을 통해 성공 확률을 원하는
    수준까지 끌어올릴 수 있다는 것은 자명하다. 또한, 기대 실행 시간이 $\log n$
    및 $1/\epsilon$에 대해 다항식인 LasVegas 공격자으로 변환하는 것도 가능하다.
\end{proof}

\begin{memo}
    알고리듬 $\cA$는 암호문의 일부만 복호화 가능하다. 예를 들어, $\epsilon =
    1/10$이라면, $\bZ^*_n$의 $1/10$ 영역만 복호화 가능하고, 나머지 $9/10$ 영역은
    복호화 불가능하다. 임의의 암호문 $c \in \bZ^*_n$을 고정하고, 알고리듬
    $\cA$에게 주어진다면, $\cA$는 복호화를 못할 수 있다.

    반면에, 알고리듬 $\cB$는 어떤 암호문이라도 상관없다. $\cB$는 어떤 암호문이라도
    $r$을 무작위로 뽑아, 균등분포를 가지는 새로운 암호문 $z$를 만들고, 이를
    $\cA$에게 전달한다. $\cA$가 복호화할 수 있는 암호문 집합에 $z$가
    속한다면($z$는 균등분포를 따르므로, 이 집합에 속할 확률은 $\epsilon$이다) $\cB$는 $z^d$에 해당하는 값을 받을
    것이고, $\cB$는 $z^d$에 $r^{-1}$을 곱해 $c^d$를 얻을 수 있다.
\end{memo}

\begin{memo}
    암호학에서 Random Self-Reducibility는 우리가 생각하는 Reduction의 일종으로
    보인다.
    \begin{itemize}
        \item Random: $\cB$가 $c$를 새로 무작위화 하여 $z$를 만든다.
        \item Self: $\cA, \cB$ 둘 다 $RSA$ 문제를 푸는 공격자이다.
        \item Reducibility: $\cB$가 $\cA$를 이용하여 문제를 푼다.
    \end{itemize}
\end{memo}

% \begin{tcolorbox}[colback=white]
% 	\centering
% 	\begin{tabularx}{\linewidth}{CcC}
% 		\underline{Adversary $\cB$} & & \underline{Adversary $\cA$} \\
% 		\\
% 		$r \rgets \mathbb{Z}_n^*$ & & \\
%         \\
%         $z \gets cr^e$ & $\xrightarrow{z}$ & \\
%         \\
%         & $\xleftarrow{w}$ & Chooses $w \in \mathbb{Z}_n^*$ \\
%         \\
%         $m' \gets wr^{-1}$ & &
%   \end{tabularx}
% \end{tcolorbox}

% \begin{memo}
%     위 그림은 알고리듬 $\cB$가 어떻게 동작하는지 그림으로 나타낸 것으로, 아주
%     간단하게만 작성하였다. (나중에 실험으로 정확하게 구성하고 싶다)
% \end{memo}

% \subsection{메인 내용}

% \begin{lemma}
%     $A$를 입력값의 $e$-제곱근의 상위 $k-k_0$ 비트들을 포함하는 $q$ 개 원소를
%     가지는 집합($q$-set)을 시간 제한 $t$ 내에 출력하며, 성공 확률은
%     $\varepsilon$인 공격자라고 하자. (여기서 입력은 partial-domain RSA 상황에
%     해당하며, $2^{k-1} < N < 2^k$를 만족하고, $k > 2k_0$이다). 이때 $(N,e)$에
%     대한 RSA 문제를 성공 확률 $\varepsilon'$로 해결하고 실행 시간 $t'$을 가지는
%     공격자 $B$가 존재한다. 여기서 다음을 만족한다.
%     $$
%         \varepsilon' \geq \varepsilon \times (\varepsilon - 2^{2k_0 - k + 6}), \quad 
%         t' \leq 2t + q^2 \times \mathcal{O}(k^3).
%     $$
% \end{lemma}

% \begin{proof}
%     RSA의 무작위 자기 환원성(random self-reducibility) 덕분에, $X = (x \cdot
%     2^{\lm_0} + r)^e \bmod N$의 $e$-제곱근의 일부 비트들과, 임의로 선택된
%     $\alpha$에 대해 $Y = X\alpha^e = (y \cdot 2^{k_0} + s)^e \bmod N$의
%     $e$-제곱근의 일부 비트들을 알게 되면, $x$와 $y$ 모두를 구할 수 있다. 

%     \begin{tcolorbox}[colback=white]
%         \centering
%         \begin{tabularx}{\linewidth}{CcC}
%             \underline{Adversary $\cB$} & & \underline{Adversary $\cA$} \\
%             \\
%             $\alpha \rgets \mathbb{Z}_n^*$ & & \\
%             \\
%             $Y \gets X \cdot \alpha^e$ & $\xrightarrow{Y}$ & \\
%             $X = (x \cdot 2^{\lm_0} + r)^e \bmod N$ & & \\
%             $Y = (y \cdot 2^{\lm_0} + s)^e \bmod N$ & & \\
%             \\
%             & $\xleftarrow{y'}$ & Chooses $y' \in \mathbb{Z}_n^*$ \\
%             \\
%             $x' \gets y' \cdot \alpha^{-1}$ & &
%       \end{tabularx}
%     \end{tcolorbox}

%     따라서,
%     $$
%         (y \cdot 2^{k_0} + s) = \alpha \times (x \cdot 2^{k_0} + r) \bmod N, \\
%         \alpha r - s = (y - x\alpha) \times 2^{k_0} \bmod N,
%     $$
%     이 식은 두 개의 미지수 $r$, $s$를 가지는 선형 모듈러 방정식이며, 이
%     미지수들은 (각각) $2^{k_0}$보다 작은 작은 해(small solution)를 가진다고
%     알려져 있다. 이 방정식은 Lemma 3을 이용하여 풀 수 있다.

%     알고리즘 $\mathcal{B}$는 다음과 같이 동작한다: $\mathcal{A}$를 $X$와
%     $X\alpha^e$를 입력으로 하여 각각 한 번씩 실행하고, 그 다음 두 결과 집합에서
%     나온 $q^2$개의 원소 쌍 각각에 대해 가우스 환원(Gaussian reduction)을
%     실행한다. 만약 부분 역상(partial pre-images)이 집합 안에 존재한다면,
%     그것들은 찾아낼 수 있다. (단, 무작위로 선택된 $\alpha$가 나쁜 경우는
%     예외이다. 이에 대해서는 Lemma~3의 가우스 환원 설명을 참조할 것.)
% \end{proof}

    