\section{OW to PD-OW}

\newcommand{\PDRSA}{\textsf{PD-RSA}}

논문 5절 Application to RSA-OAEP에는 다음과 같은 내용이 있다.

\begin{quote}
    \noindent
    thanks to the random self-reducibility of RSA, \textbf{the partial-domain
    one-wayness of RSA is equivalent to that of the whole RSA problem}, as soon
    as a constant fraction of the most significant bits (or the least
    significant bits) of the pre-image can be recovered.
    
    이는 RSA의 무작위 자기환원성 덕분인데, \textbf{RSA의 부분 영역 일방향성은
    전체 RSA 문제의 일방향성과 동등하며}, 이는 전상 이미지(pre-image)의 가장
    상위 비트(또는 가장 하위 비트)의 일정 비율을 복구할 수 있을 때 성립합니다.
\end{quote}

본 절에서는 RSA의 부분 영역 일방향성이 전체 RSA 문제의 일방향성과 동등함을 보인다.

\begin{memo}
    본 논문의 제목은 `RSA-OAEP is Secure under the RSA Assumption'이다. 이는
    RSA가 OW일 때, RSA-OAEP가 IND-CCA2 안전함을 말하는 제목이다. 그러나 논문의
    4절에서는 RSA가 PD-OW일 때를 가정하고 IND-CCA2 안전함을 보인다.

    만약 RSA가 OW일 때, RSA는 PD-OW도 만족한다면, OW, PD-OW, IND-CCA2로
    연결될 수 있다. 그러나 RSA가 OW일 때, PD-OW를 만족함은 자명하지 않다. (그
    역은 자명하다) 논문의 5절에서는 이에 대해 증명하여, OW와 PD-OW가 동등함을
    보인다. 그리고 증명하는데 사용하는 기법이 Random Self-Reducibility이다.
\end{memo}

\subsection{RSA Assumption}
RSA 문제란, 공격자에게 $(N, e)$와 암호문 $c = m^e \bmod N$이 주어졌을 때, $d$
없이 $m$을 출력할 수 있는가를 묻는 문제이다. 이 문제를 실험으로 구성하면 그림
\ref{fig:rsa-problem}와 같다.

\newcommand{\RSA}{\textsf{RSA}}

\begin{figure}[ht]
    \begin{tcolorbox}[colback=white]
        \centering
        \begin{tabularx}{\linewidth}{CcC}
            \underline{Challenger $\cC$} & $\xLeftrightarrow{\EXP^{\RSA}}$ & \underline{Adversary $\cA$} \\
            \\
            $(N, e, d) \gets \textsf{RSA.KeyGen}(1^{\lambda})$ & & \\
            \\
            $M \rgets \bZ_N$ & & \\
            $c \gets m^e \bmod N$ & $\xrightarrow{N, e, c}$ & \\
            \\
            Return $[m' \issame m]$ & $\xleftarrow{m'}$ & $\cA$ chooses $m' \in \bZ_N$ \\
        \end{tabularx}
    \end{tcolorbox}
    \caption{$\RSA$ 실험}
    \label{fig:rsa-problem}
\end{figure}

다음은 $\PDRSA$ 실험으로, $\PDOW$ 실험과 유사하다.

\begin{figure}[ht]
    \begin{tcolorbox}[colback=white]
        \centering
        \begin{tabularx}{\linewidth}{CcC}
            \underline{Challenger $\cC$} & $\xLeftrightarrow{\EXP^{\PDRSA}}$ & \underline{Adversary $\cA$} \\
            \\
            $(N, e, d) \gets \textsf{RSA.KeyGen}(1^{\lambda})$ & & \\
            \\
            $x \rgets \set{0, 1}^{\lambda - \lambda_0}$ & & \\
            $r \rgets \set{0, 1}^{\lambda_0}$ & & \\
            $c \gets (x \cdot 2^{\lambda_0} + r)^e \bmod N$ & $\xrightarrow{N, e, c}$ & \\
            \\
            Return $[x' \issame x]$ & $\xleftarrow{x'}$ & $\cA$ chooses $x' \in \set{0, 1}^{\lambda - \lambda_0}$ \\
        \end{tabularx}
    \end{tcolorbox}
    \caption{$\PDRSA$ 실험}
    \label{fig:pdrsa-problem}
\end{figure}

RSA 가정(Assumption)은 $n$이 충분히 클 때 RSA 문제를 풀기 어렵다는 것이다. 즉
그림 \ref{fig:rsa-problem}의 실험이 $1$을 반환할 확률이 매우 작음을 의미한다.
가정은 RSA 함수가 트랩도어 일방향 함수(trapdoor oneway function)라는 말과
동일하다 (이때 비밀키가 트랩도어 역할을 한다). 이에 대한 정의는 이미 했으므로
생략한다.

\subsection{Random Self-Reducibility}

이제 무작위 자기 환원성(Random Self-Reducibility, 이하 RSR)에 대해
설명한다.\footnote{여기서는 `Rajeev Motwani and Prabhakar Raghavan. Randomized
Algorithms. Cambridge University Press, 1995'의 Section 14.4의 내용을 바탕으로
한다.} 임의의 공격자 $\cA$에 대해, 집합 $C(\cA)$를 다음과 같이 정의한다.
$$
    C(\cA) := \{ c \in \bZ_N : \cA \text{ can compute $c^d \bmod N$, given that $\cA$ knows only $N$ and $e$} \}.
$$
$C(\cA)$는 공격자 $\cA$가 비밀키 없이 복호화할 수 있는 암호문 집합을 의미한다.
공격자가 어떤 암호문 $c$를 받았을 때, 그 암호문이 $C(\cA)$에 속하면, 공격자는
$c^d \bmod N$을 계산할 수 있다.

만약 공격자가 암호문의 $10\%$를 복호화 할 수 있다면, 집합 $C(\cA)$의 크기는
$N/10$, 즉 $|C(\cA)| = N/10$이다. 만약 공격자가 암호문의 비율 $\varepsilon$ 만큼
복호화 할 수 있다면, 집합 $|C(\cA)| = \varepsilon \cdot N$이다.

\begin{tcolorbox}[colback=white, boxrule=0.7pt, sharp corners] 
    \begin{theorem}
        $\negl > 0$에 대해 $|C(\cA)| \geq \negl \cdot n$을 만족하는 RSA 공격자
        $\cA$를 고려하자. 그러면 $|C(\cB)| = n$을 만족하는 RSA 공격자 $\cB$가
        존재하며, 실행 시간은 $\log n$과 $1/\negl$에 대한 다항식이다.
    \end{theorem}
\end{tcolorbox}

\begin{proof}
    다음과 같은 공격자 $\cB$를 고려하자. (그림 \ref{fig:rsr}을 참고한다)
    \begin{itemize}
        \item 공격자 $\cB$는 무작위 값 $\alpha \in \mathbb{Z}_N^*$를 선택하고 $c' =
        cr^e \bmod N$를 계산한다. 
        \item $c'$을 공격자 $\cA$에게 전달한다.
        \item $\cA$로부터 받은 값에 $\alpha$의 곱셈 역원을 곱하고, 그 결과를 도전자
        $\cC$에게 전달한다.
    \end{itemize}

    \begin{figure}[ht]
        \begin{tcolorbox}[colback=white]
        \centering
            \begin{tabularx}{\linewidth}{CcCcC}
                \underline{Challenger $\cC$} & $\xLeftrightarrow{\EXP^{\RSA}}$ & \underline{Adversary $\cB$} & $\xLeftrightarrow{\EXP^{\RSA}}$ & \underline{Adversary $\cA$} \\
                \\
                $(N, e, d) \gets \textsf{RSA.KeyGen}(1^{\lambda})$ & & & & \\
                \\
                $M \rgets \bZ_N$ & & & & \\
                $c \gets m^e \bmod N$ & $\xrightarrow{c}$ & & & \\
                \\
                & & $\alpha \rgets \bZ^*_N$ & & \\
                & & $c' \gets c \alpha^e \bmod N$ & $\xrightarrow{c'}$ & \\
                \\
                & & & $\xleftarrow{m'}$ & $\cA$ chooses $m' \in \bZ_N$ \\
                \\
                Return $[m'' \issame m]$ & $\xleftarrow{m''}$ & $m'' \gets m' \alpha^{-1}$ & & \\
            \end{tabularx}  
        \end{tcolorbox}
        \caption{RSR 실험}
        \label{fig:rsr}
    \end{figure}

    만약 $c \in C(\cA)$라면, 공격자 $\cA$는 $m' = (c')^d \bmod N$을 계산하여
    $\cB$에게 전달할 수 있다. $m'$은 다음을 만족한다.
    $$
        m' \equiv (c')^d 
        \equiv (c \cdot \alpha^e)^d 
        \equiv c^d \cdot \alpha^{ed} 
        \equiv c^d \cdot \alpha \pmod N.
    $$
    따라서 $\cB$는 $m'$에 $\alpha^{-1}$을 곱하여 $m$을 얻을 수 있다. 공격자
    $\cA$의 공격 성공 비율은 $\varepsilon$이므로, $c'$이 균등분포를 만족한다면,
    공격자 $\cA$의 공격성공 확률은 $\varepsilon$이며, 공격자 $\cB$는 최소
    $\varepsilon$의 확률로 공격에 성공한다. 

    공격자 $\cB$는 독립 반복으로 공격자 $\cA$에게 암호문을 전달함으로써 공격
    성공 확률을 원하는 수준까지 끌어올릴 수 있다. 이때 기대 실행 시간은 $\log N$
    및 $1/\varepsilon$에 대한 다항식이다.

    \begin{memo}
        $\log N$은 $c'$과 $\alpha^{-1}$을 계산하는 데 걸리는 시간,
        $1/\varepsilon$은 독립 반복 횟수를 표현한다.
    \end{memo}

    이제 $c'$이 균등분포를 만족함을 보이고 증명을 마친다. 이는 곱셈과 $e$ 제곱
    연산이 군 $\mathbb{Z}_N^*$에서 일대일 대응이면서 전사 함수(즉, 순열)라는
    관찰에서 따라온다. 따라서 무작위 $r$에 대해 $z = cr^e$ 역시
    $\mathbb{Z}_N^*$에서 균등하게 분포한다.
\end{proof}

% \begin{memo}
%     $\cB$는 어떤 암호문이라도 상관없다. $\cB$는 어떤 암호문이라도
%     $r$을 무작위로 뽑아, 균등분포를 가지는 새로운 암호문 $z$를 만들고, 이를
%     $\cA$에게 전달한다. $\cA$가 복호화할 수 있는 암호문 집합에 $z$가
%     속한다면($z$는 균등분포를 따르므로, 이 집합에 속할 확률은 $\epsilon$이다) $\cB$는 $z^d$에 해당하는 값을 받을
%     것이고, $\cB$는 $z^d$에 $r^{-1}$을 곱해 $c^d$를 얻을 수 있다.
% \end{memo}

% \begin{memo}
%     암호학에서 Random Self-Reducibility는 우리가 생각하는 Reduction의 일종으로
%     보인다.
%     \begin{itemize}
%         \item Random: $\cB$가 $c$를 새로 무작위화 하여 $z$를 만든다.
%         \item Self: $\cA, \cB$ 둘 다 $RSA$ 문제를 푸는 공격자이다.
%         \item Reducibility: $\cB$가 $\cA$를 이용하여 문제를 푼다.
%     \end{itemize}
% \end{memo}

% \begin{tcolorbox}[colback=white]
% 	\centering
% 	\begin{tabularx}{\linewidth}{CcC}
% 		\underline{Adversary $\cB$} & & \underline{Adversary $\cA$} \\
% 		\\
% 		$r \rgets \mathbb{Z}_n^*$ & & \\
%         \\
%         $z \gets cr^e$ & $\xrightarrow{z}$ & \\
%         \\
%         & $\xleftarrow{w}$ & Chooses $w \in \mathbb{Z}_n^*$ \\
%         \\
%         $m' \gets wr^{-1}$ & &
%   \end{tabularx}
% \end{tcolorbox}

% \begin{memo}
%     위 그림은 알고리듬 $\cB$가 어떻게 동작하는지 그림으로 나타낸 것으로, 아주
%     간단하게만 작성하였다. (나중에 실험으로 정확하게 구성하고 싶다)
% \end{memo}

\subsection{Proof of OW implies PD-OW}

지금부터 RSA가 OW이면, RSA는 PD-OW임을 증명한다. 먼저, 다음 보조정리를 증명한다.

\begin{tcolorbox}[colback=white, sharp corners, boxrule=0.7pt]
    \begin{lemma}
        $2^{\lambda_0 - 1} < N < 2^{\lambda_0}$를 만족하고, $\lambda >
        2\lambda_0$라고 하자. $\PDRSA$ 공격자 $\cA$를 고려하자. 공격자 $\cA$의
        동작 시간은 $t$, 성공 확률은 $\varepsilon$, 출력 개수는 $q$라고 하자.
        이때 성공 확률 $\varepsilon'$, 실행 시간 $t'$을 가지는 $\RSA$ 공격자
        $\cB$가 존재하며, 다음을 만족한다.
        $$
            \varepsilon' \geq \varepsilon \times (\varepsilon - 2^{2\lambda_0 - \lambda + 6}), 
            \quad t' \leq 2t + q^2 \times \mathcal{O}(\lambda^3).
        $$
    \end{lemma}
\end{tcolorbox}

\begin{proof}
    다음과 같이 실험을 구성한다. 공격자 $\cB$는 $\RSA$(또는 $\OW$) 공격자이고,
    공격자 $\cA$는 $\PDRSA$(또는 $\PDOW$) 공격자이다. 공격자 $\cB$는 암호문
    $X$와 새로 만든 암호문 $Y$를 공격자 $\cA$에게 전달한다. $\cA$는 $X,Y$의
    상위비트에 해당하는 값을 $q$개씩 선택하여 $\cB$에게 전달한다. $\cB$는
    $q^2$개의 쌍으로부터 암호문 $X$의 하위비트를 찾고, $X$에 대응되는 평문 $Z$를 만든다.
    \begin{tcolorbox}[colback=white]
        \centering
        \begin{tabularx}{\linewidth}{CcCcC}
            \underline{Challenger $\cC$} & $\xLeftrightarrow{\EXP^{\RSA}}$ & \underline{Adversary $\cB$} & $\xLeftrightarrow{\EXP^{\PDRSA}}$ & \underline{Adversary $\cA$} \\
            \\
            $(N, e, d) \gets \textsf{RSA.KeyGen}(1^{\lambda})$ & & & & \\
            \\
            $x \rgets \set{0, 1}^{\lambda - \lambda_0}$ & & & & \\
            $r \rgets \set{0, 1}^{\lambda_0}$ & & & & \\
            $Z \gets x \cdot 2^{\lambda_0} + r$ & & & & \\
            $X \gets Z^e \bmod N$ & $\xrightarrow{X}$ & & $\xrightarrow{X}$ & \\
            \\
            & & & $\xleftarrow{x_1', \cdots , x'_q}$ & $\cA$ chooses $x_1', x_2', \cdots, x_q'$ \\
            \\
            & & $\alpha \rgets [0, N-1]$ & & \\
            & & $Y \gets X \cdot \alpha^e \bmod N$ & $\xrightarrow{Y}$ & \\
            & & {\fontsize{7pt}{8.4pt}\selectfont $Y = (y \cdot 2^{\lambda_0} + s)^e \bmod N$} & & \\
            \\
            & & & $\xleftarrow{y_1', \cdots , y'_q}$ & $\cA$ chooses $y_1', y_2', \cdots, y_q'$ \\
            \\
            Return $[Z' \issame Z]$ & $\xleftarrow{Z'}$ & use Lemma \ref{lem:small-solution} for $(x'_i, y'_i), i \in [1, q-1]$ & & \\
      \end{tabularx}
    \end{tcolorbox}

    $Y$는 또 다른 암호문으로, $Y = (y \cdot 2^{\lambda_0} + s)^e \bmod N$로
    표현할 수 있다. 또한 $Y$는 다음을 만족한다.
    \begin{align*}
        Y &\equiv X \cdot \alpha^e \\ 
        &\equiv (x \cdot 2^{\lambda_0} + r)^e \cdot \alpha^e \\
        &\equiv (\alpha \cdot (x \cdot 2^{\lambda_0} + r))^e \\
        &\equiv (\alpha \cdot x \cdot 2^{\lambda_0} + \alpha \cdot r)^e \\
        &\equiv (y \cdot 2^{\lambda_0} + s)^e \pmod N.
    \end{align*}
    % 위 실험에서 공격자 $\cA$는 $\negl$의 확률로 $y' = y$를 공격자 $\cB$에게 전달한다. 그리고
    % $\cB$는 $x' = x$를 도전자 $\cC$에게 전달한다. 즉, 공격자 $\cB$는 $\negl$의
    % 확률로 $x, y$ 값을 알 수 있다.
    우리는 $y \cdot 2^{\lambda_0} + s = \alpha \cdot x \cdot 2^{k_0} + \alpha \cdot r
    \bmod N$으로부터 다음 식을 유도할 수 있다.
    $$
        \alpha r - s = (y - x\alpha) \times 2^{\lambda_0} \bmod N.
    $$
    이 식은 두 개의 미지수 $r$, $s$를 가지는 선형 모듈러 방정식이며, 보조정리
    \ref{lem:small-solution}을 이용하여 풀 수 있다. 만약 그렇게 찾은 $r'$과
    $x'$으로 $Z' = x' \cdot 2^{\lambda_0} + r'$을 계산한다.
    
    % (두 미지수는 각각
    % $2^{\lambda_0}$보다 작은 작은 해(small solution)를 가진다고 알려져 있다.)

    % 알고리즘 $\mathcal{B}$는 다음과 같이 동작한다: $\mathcal{A}$를 $X$와
    % $X\alpha^e$를 입력으로 하여 각각 한 번씩 실행하고, 그 다음 두 결과 집합에서
    % 나온 $q^2$개의 원소 쌍 각각에 대해 가우스 환원(Gaussian reduction)을
    % 실행한다. 만약 부분 역상(partial pre-images)이 집합 안에 존재한다면,
    % 그것들은 찾아낼 수 있다. (단, 무작위로 선택된 $\alpha$가 나쁜 경우는
    % 예외이다. 이에 대해서는 Lemma~3의 가우스 환원 설명을 참조할 것.)
\end{proof}

    