\section{증명}

\begin{tcolorbox}[colback=white]
	\begin{lemma}
		공격자 $\cA$를 OAEP 변환 $(\cK, \cE, \cD)$에 대해 동작시간 $\tau$를 가지고,
		복호화 오라클 $\cO^{\cD}$와 랜덤 오라클 $\cO^{H}, \cO^{G}$에 각각 $q_{\cD},
		q_{H}, q_{G}$회 질의하는 $\textsf{IND-CCA2}$ 공격자라 하자. 이때, 다음을
		만족하는 $\SPDOW$ 공격자 $\cB$가 존재한다.
		$$
			\ADV^{\SPDOW}_{\Psi, \lm}(\cB; \tau', q_{H})
		  	\ge \frac{\ADV^{\INDCCA}_{\Pi, \lm}(\cA; \tau, q_{\cD}, q_{H}, q_{G})}{2}
		   	- \frac{2q_{\cD}q_{G} + q_{\cD} + q_{G}}{2^{\lm_0}}
		   	- \frac{2q_{\cD}}{2^{\lm_1}}.
		$$
	  	여기서, $\tau' \le \tau \cdot q_{H} \cdot q_{G} \cdot (T_{\cF} +
	   	O(1))$이고, $T_{\cF}$는 트랩도어 치환 $\cF$의 시간 복잡도를 의미한다.
	\end{lemma}
\end{tcolorbox}

% \begin{tcolorbox}
% 	우리는 $\text{Succ}^{\text{OW}}(\tau)$, (그리고 각각 $\text{Succ}^{\text{pd-OW}}(\tau)$ 및 $\text{Succ}^{\text{s-pd-OW}}(\ell, \tau)$)를 최대 성공 확률 $\text{Succ}^{\text{OW}}(\mathcal{A})$ (그리고 각각 $\text{Succ}^{\text{pd-OW}}(\mathcal{A})$ 및 $\text{Succ}^{\text{s-pd-OW}}(\mathcal{A})$)로 정의한다. 여기서 최대값은 실행 시간이 $\tau$ 이하로 제한된 모든 공격자(adversary)에 대해 계산된다.

% 세 번째 경우에서는 $\mathcal{A}$가 $\ell$개의 원소를 포함하는 집합을 출력한다는 추가적인 제한이 존재한다. 따라서, 모든 $\tau$ 및 $\ell \geq 1$에 대해 다음이 성립함이 분명하다.

% $$
% \text{Succ}^{\text{s-pd-OW}}(\ell, \tau) \geq \text{Succ}^{\text{pd-OW}}(\tau) \geq \text{Succ}^{\text{OW}}(\tau).
% $$

% 또한, 공격자가 반환한 집합에서 무작위로 원소를 선택함으로써 집합 부분 도메인 단방향성(Set Partial-Domain One-Wayness)을 깨뜨릴 수 있으며, 그 확률은 $\text{Succ}^{\text{s-pd-OW}}(\mathcal{A}) / \ell$이다. 이를 통해 다음의 부등식이 성립한다.

% $$
% \text{Succ}^{\text{pd-OW}}(\tau) \geq \text{Succ}^{\text{s-pd-OW}}(\ell, \tau) / \ell.
% $$

% 그러나 특정한 함수 $f$에 대해 보다 효율적인 환원이 존재할 수도 있다. 또한, 어떤 경우에는 세 가지 문제 모두 다항식적으로 동등할 수 있다. 이는 RSA 치환(RSA permutation)의 경우에 해당하며, 따라서 이에 대한 결과는 6장에서 다룬다.
% \end{tcolorbox}

% 우리는 보조정리 2를 세 단계로 증명한다. 첫 번째 단계에서는 $\INDCCA$ 적대자
% $\cA$를 부분 도메인 일방성(partial-domain one-wayness) $f$를 깨뜨리는 알고리즘
% $\cB$로 환원하는 과정을 제시한다. 현재의 증명에서는 원본 논문 [3]에서와 같은
% 전체 도메인 일방성(full-domain one-wayness)이 아니라, 부분 도메인 일방성
% 하에서의 보안성에만 관심을 둔다. 두 번째 단계에서는 이 환원에서 사용된 복호화
% 오라클 시뮬레이션이 부분 도메인 일방성 하에서 압도적인 확률로 올바르게 동작함을
% 보인다. 이 부분은 원본 증명 [3]과 다르며, 최근 발견된 오류 [15]를 수정한다.
% 마지막으로, 우리는 복호화 오라클 시뮬레이션에 대한 위에서 언급한 분석을 포함하여
% 전체적인 환원의 성공 확률을 분석한다.

% 이 첫 번째 부분에서는 환원이 어떻게 작동하는지를 다시 살펴본다. $\cA$를
% $(\cK, \cE, \cD)$의 $\INDCCA$ 공격자로 가정하자. 시간 제한 $\tau$ 내에서,
% $\cA$는 복호화 오라클에 대해 $q_{\cD}$개의 질의를 하고, 무작위 오라클 $H,
% G$에 대해 각각 $q_{H}, q_{G}$개의 질의를 수행하며, 특정 확률
% $\negl$보다 높은 능력치로 올바른 평문을 구별해낸다. 이제 환원 $\cB$을 설명한다.

\subsection{증명: Reduction and simulation}

\begin{tcolorbox}[colback=white]
	\centering
	\begin{tabularx}{\linewidth}{CcCcC}
		\underline{Challenger $\cC$} & $\xLeftrightarrow{\EXP^{\SPDOW}_{\Psi, \lm}}$ & \underline{Adversary $\cB$} & $\xLeftrightarrow{\EXP^{\INDCCAROM}_{\Pi, \lm}}$ & \underline{Adversary $\cA$} \\
		\\
		$(\pk, \sk) \gets \cK(1^{\lm})$ & &  &  & \\
		\\
		$(s^*, t^*) \rgets \bset^{\lm - \lm_0} \times \bset^{\lm_0}$ \newline $c^* \gets \cF_{\pk}(s^*, t^*)$ & $\xrightarrow{1^{\lm}, \pk, c^*}$ & & & \\
		\\
		 & & $\cL_{H}, \cL_{G} \gets \set{}, \set{}$ & $\xrightarrow{1^{\lm}, \pk}$ & \\
		\\
		 & & \multicolumn{3}{c}{\cellcolor{gray!20}$\cO^{\cD_{\sk}}, \cO^{H}, \cO^{G}$ Query Phase 1} \\
		\\
		& & & $\xleftarrow{m^*_0, m^*_1}$ & $\cA$ chooses $m^*_0, m^*_1 \in \cM$ such that $|m^*_0| = |m^*_1|$ and $m^*_0 \neq m^*_1$ \\
		\\
		 & & $b \rgets \bset$ & $\xrightarrow{c^*}$ & \\
		\\
		 & & \multicolumn{3}{c}{\cellcolor{gray!20}$\cO^{\cD_{\sk}}, \cO^{H}, \cO^{G}$ Query Phase 2} \\
		\\
		Return $s^* \isin S'$ & $\xleftarrow{S'}$ & $\cB$ chooses $S' = \set{s \in \cL_{H}}$ & $\xleftarrow{b'}$ & $\cA$ chooses $b' \in \bset$ \\
  \end{tabularx}
\end{tcolorbox}

% 이 실험에서 세 개의 오라클을 $\cB$가 처리하기 때문에, 다음을 고려해야한다.
% \begin{itemize}
% 	\item 공격자 $\cA$의 질의에 대해서, 오라클은 유효한 응답을 해야 한다. $\cA$가
% 	오라클이 잘못된 응답을 하고 있다는 것을 감지해서는 안된다.
% 	\item 오라클이 기대하는 확률분포와 일관되어야 한다. 일관되지 않으면 $\cA$가
% 	이상을 감지할 수 있다.
% 	\item 오라클 응답은 일관되어야 한다.
% 	\item 복호화 오라클은 $\cB$가 비밀키를 모름에도 수행할 수 있어야 한다.
% \end{itemize}

% \begin{memo}
% 	오라클을 현실적으로 모델링할 때는 다음을 고려해야 한다.
% 	\begin{itemize}
% 		\item 응답이 유효해야 한다.
% 		\item 질의한 상대방이 오라클에 기대하는 확률 분포와 동일해야 한다. 예를
% 			  들어, 랜덤 오라클에 질의했다고 한다면, 모델링한 오라클은
% 			  균등분포를 따라야 한다.
% 		\item 복호화 오라클의 경우, 트랩도어 없이 모델링해야 한다.
% 	\end{itemize}
% \end{memo}

먼저, 공격자 $\cB$가 $\cO^{H}$를 동작시키는 시뮬레이션을 정의한다. 공격자
$\cA$가 랜덤 오라클 $\cO^{H}$에 $\delta$를 질의했다고 하자. 공격자 $\cB$는
다음과 같이 $H_{\delta}$를 응답한다.
\begin{enumerate}
	\item 만약 $\delta$가 $\cL_{H}$에 있다면, $\delta$에 대응하는 $H_\delta$를
	응답한다. (즉, $(\delta, H_{\delta}) \in \cL_{H}$)
	\item 만약 $\delta$가 $\cL_{H}$에 없다면, $H_{\delta} \rgets \set{0
	,1}^{\lm_0}$을 수행한 후 $H_{\delta}$를 응답한다. 이후 $\cL_{H} \gets \cL_{H}
	\cap (\delta, H_{\delta})$를 수행한다.
\end{enumerate}

다음으로, 공격자 $\cB$가 $\cO^{G}$를 동작시키는 시뮬레이션을 정의한다. 공격자
$\cA$가 랜덤 오라클 $\cO^{G}$에 $\gamma$를 질의했다고 하자. 공격자 $\cB$는
다음과 같이 $G_{\gamma}$를 응답한다.
\begin{enumerate}
	\item 만약 $\gamma$가 $\cL_{G}$에 있다면, $\gamma$에 대응하는 $G_{\gamma}$를
	응답한다.
	\item 만약 $\gamma$가 $\cL_{G}$에 없다면, 다음 과정을 진행한다.
	\begin{enumerate}
		\item 어떤 $(\delta, H_{\delta}) \in \cL_{H}$에 대해, 만약 $c^* =
		\cF_{\pk}(\delta, \gamma \xor H_{\delta})$라면, 우리는 여전히 $G$를 올바르게
		시뮬레이션할 수 있다. 이 때 응답은 $G_{\gamma} \gets \delta \xor (m_{b}
		\parallel 0^{\lm_1})$이다. $\delta = s^*$이고 $s^*$가 균등하게 분포하므로
		$G_\gamma$는 균등 분포된 값이 된다. 
		\item 모든 $(\delta, H_{\delta}) \in \cL_{H}$에 대해, 만약 $c^* \neq
		\cF_{\pk}(\delta, \gamma \xor H_{\delta})$라면, $G_{\gamma} \rgets \set{0
		,1}^{n + \lm_1}$를 수행한다.
		\item $G_{\gamma}$를 응답한 후, $\cL_{G} \gets \cL_{G} \cap (\gamma,
		G_{\gamma})$를 수행한다.
	\end{enumerate}
\end{enumerate}

% \begin{tcolorbox}
% 	\centering
% 	\begin{tabularx}{\linewidth}{CcC}
% 		\underline{Adversary $\cB$} & & \underline{Adversary $\cA$} \\
% 		\\
% 		& $\xleftarrow{\gamma}$ & $\cA$ Chooses $\gamma \in \bset$ \\
% 		If $\gamma \in \cL_{G}$, then $G_{\gamma} \gets \cL_{G}$ & & \\
% 		Otherwise, & & \\
% 	\end{tabularx}
% \end{tcolorbox}

마지막으로, 공격자 $\cB$가 $\cO^{\cD}$를 동작시키는 시뮬레이션을 정의한다.
공격자 $\cA$가 랜덤 오라클 $\cO^{\cD}$에 $c = \cF_{\pk}(s, t)$를 질의했다고
하자. 공격자 $\cB$는 다음과 같이 응답한다.
\begin{enumerate}
	\item $\cL_{G}$의 질의 응답 쌍 $(\gamma, G_\gamma) \in \cL_{G}$ 및 $\cL_{H}$의
	$(\delta, H_\delta) \in \cL_{H}$를 조회하고, 각 리스트에서 선택된 쌍에 대해
	다음과 같이 정의한다.
	$$
		\sigma = \delta, 
		\quad \tau = \gamma \xor H_\delta, 
		\quad \mu = G_\gamma \xor \delta.
	$$
	만약 $c = \cF_{\pk}(\sigma, \tau)$이면서 $[\mu]_{\lm_1} = 0^{\lm_1}$라면,
	$[\mu]^{n}$을 응답한다.
	\item 그 외에는 $\REJECT$를 응답한다.
\end{enumerate}

\subsection{증명: 사건 정의}

\begin{table}[ht]
	\centering
	\caption{오라클 관련 사건 정의}
	\vspace{10pt}
	\renewcommand{\arraystretch}{1.15}
	\begin{tabularx}{\textwidth}{p{1cm}X}
	\toprule
	$\askG$ & $r^*$가 $\cO^{G}$에 질의되었을(has been asked) 사건. \\
	$\askH$ & $s^*$가 $\cO^{H}$에 질의되었을 사건. \\
	$\Gbad$ & $\cO^{G}$에 $r^*$를 질의했지만, $\cO^{G}$의 응답이
	$s^* \xor (m_{b} \parallel 0^{\sk})$가 아닌 사건. $\Gbad$가 발생하면,
	$\askG$도 발생한다. \\ % $\Gbad$는 랜덤 오라클을 \textit{불완전(imperfect)}하게 만드는 유일한 사건이다.
	$\Dbad$ & \sout{CPA 시나리오에서 복호화가 실패하는 사건.} \\
	$\Bad$ & \sout{$\Gbad \vee \Dbad$.} \\
	\bottomrule
	\end{tabularx}
\end{table}

공격자 $\cA$는 복호화 오라클 $\cO^{\cD}$에 암호문 $c = \cF_{\pk}(s, t)$를
질의할 수 있다. 질의한 암호문 $c$와 관련된 사건을 다음 표와 같이 정의한다.
\begin{table}[ht]
	\centering
	\caption{복호화 시뮬레이션 관련 사건 정의}
	\vspace{10pt}
	\renewcommand{\arraystretch}{1.15}
	\begin{tabularx}{\textwidth}{p{1cm}X}
	\toprule
	$\Sbad$ & $s = s^*$인 사건. \\
	$\Rbad$ & $r = r^*$인 사건. 즉, $H(s) \xor t =  H(s^*) \xor
	t^*$인 사건. \\
	$\Cbad$ & $\Sbad \vee \Rbad.$ \\
	$\askR$ & $r$이 $\cO^{G}$에 질의되었을 사건. 즉, $H(s) \xor t$이 질의되었을 사건 \\
	$\askS$ & $s$가 $\cO^{H}$에 질의되었을 사건. \\
	$\askRS$ & $\askR \land \askS$ \\
	$\Fail$ & 복호화 오라클이 질의 $c$에 대해 잘못 응답하는 사건. $i$번째 질의
	$c_i$에 대해서는 $\Fail_i$로 나타낸다. 여기서 $i = 1, \cdots,
	q_{\cD}$이다. \question{어떤 $i$에 대해서도 $\Fail_i$의 확률을 균등하게
	평가(evaluate)할 수 있으므로, 여기서는 사용하지 않는다. $\Fail$ 사건은 평문
	추출기(plaintext extractor)가 실제 복호화 오라클에서는 허용될 암호문을
	거부하는 경우로 제한된다. 실제로, 추출기가 암호문을 허용하는 순간, 해당
	암호문이 유효하며 출력 평문과 일치함을 알 수 있다.} \\
	\bottomrule
	\end{tabularx}
\end{table}

\subsection{증명: Analysis of the Decryption Oracle Simulation}

% 우리는 다음과 같은 주장을 하며, 이는 새로운 계산적 가정을 기반으로 이전 증명
% [3]을 수정하는 것이다. 보다 정확히 말하면, 평문 인식성(plaintext-awareness)의
% 수정된 정의 [1]로 인해 고려해야 할 추가적인 경우들이 순열 $f$의 부분 영역
% 단방향성(partial-domain one-wayness) 하에서 매우 낮은 확률로 발생함을 보인다.

\begin{tcolorbox}[colback=white]
	\begin{lemma}
		$s^*$가 $\cO^{H}$에 질의되지 않았을 때, $\cO^{\cD}$는 질의된
		암호문 $c$ $(c \neq c^*)$에 대해 출력을 정확히 생성할 수 있으며, 이
		확률은 다음보다 크거나 같다.
		$$
			1 - \left( \frac{2}{2^{k_1}} + \frac{2q_G + 1}{2^{k_0}} \right).
		$$
		또한, 시간 제한 $t' \leq q_G \cdot q_H \cdot (T_{\cF} + O(1))$ 내에서 이를 수행할 수 있다.
	\end{lemma}
\end{tcolorbox}

\begin{proof}
	본 증명에서는 다음이 참임을 보인다.
	$$
		\Pr[\Fail \mid \neg\askH] \le  \frac{2}{2^{\lm_1}} + \frac{2q_{G} + 1}{2^{\lm_0}}.
	$$
	$\Pr[\Fail \mid \neg\askH]$는 다음과 같이 표현 가능하다.
	$$
		\Pr[\Fail \land \Cbad \mid \neg\askH]
		+ \Pr[\Fail \land \neg\Cbad \mid \neg\askH].
	$$
	본 증명에서는 먼저 $\Pr[\Fail \land \Cbad \mid \neg\askH]$를 구한다. $\Cbad
	= \Sbad \lor (\Rbad \land \neg\Sbad)$를 이용하여, 이 확률을 다음과 같이 표현한다.
	\begin{align*}
		&\Pr[\Fail \land \Cbad \mid \neg\askH] \\
		&= \Pr[\Fail \land (\Sbad \lor (\Rbad \land \neg\Sbad)) \mid \neg\askH] \\
		&= \Pr[(\Fail \land \Sbad) \lor (\Fail \land \Rbad \land \neg\Sbad) \mid \neg\askH] \\
		&\le \Pr[\Fail \land \Sbad \mid \neg\askH] + \Pr[\Fail \land \Rbad \land \neg\Sbad \mid \neg\askH] \\
		&\le \Pr[\Fail \land \Sbad \mid \neg\askH] + \Pr[\Rbad \land \neg\Sbad \mid \neg\askH] \\
		&\le \Pr[\Fail \mid \Sbad \land \neg\askH] + \Pr[\Rbad \mid \neg\Sbad \land \neg\askH]. \\
		&= \Pr[\Fail \land \askR \mid \Sbad \land \neg\askH] + \Pr[\Fail \land \neg\askR \mid \Sbad \land \neg\askH] + \Pr[\Rbad \mid \neg\Sbad \land \neg\askH]. \\
		&\le \Pr[\askR \mid \Sbad \land \neg\askH] + \Pr[\Fail \mid \neg\askR \land \Sbad \land \neg\askH] + \Pr[\Rbad \mid \neg\Sbad \land \neg\askH].
	\end{align*}
	세 번째 사건은 $s \ne s^*$이고 공격자 $\cA$가 $s^*$에 대해
	$\cO^{H}$에 질의하지 않았을 때 $\Rbad$가 발생함을 의미한다. $s^*$가
	$\cO^H$에 질의되지 않았고 $s \ne s^*$일 때, $H(s^*)$는 예측
	불가능(unpredictable)하며 $H(s)$뿐 아니라 $t$, $t^*$와도 독립적이다.
	이때 RBad 사건, $H(s^*) = H(s) \xor t \xor t^*$ 는 최대
	$2^{-\lm_0}$의 확률로 발생한다. 즉, 다음과 같다.
	$$
		\Pr[\Rbad \mid \neg\Sbad \land \neg\askH] \le 2^{-\lm_0}.
	$$
	첫 번째 사건은 $s = s^*$이며 $H(s^*)$는 예측 불가능할 때, $r$이
	$\cO^{G}$에 대해 질의되었을 사건을 의미한다. 이때, $H(s)$ 또한 예측
	불가능하다. 즉, $r = H(s) \xor t$가 예측 불가능하므로, $r$이 $\cO^G$에
	질의되었을 확률은 최대 $q_G \cdot 2^{-\lambda_0}$이다. 즉, 다음과 같다.
	$$
		\Pr[\askR \mid \Sbad \land \neg\askH] \le q_{G} \cdot 2^{-\lm_0}.
	$$
	두 번째 사건은 복호화 시뮬레이션에서 $H(s)$는 예측 불가능하고 $r$은 $\cO^G$에
	질의되지 않았을 때, 유효한 암호문 $c$를 거부하는 경우이다. \question{페이스텔
	네트워크(Feistel network)의 일대일 성질에 따라 $s = s^*$이면 $r \ne
	r^*$이고, 따라서 $G(r)$는 예측 불가능하다.} 그러므로 이 경우 중복 조건은
	$2^{-\lm_1}$보다 큰 확률로 성립할 수 없다. 즉, 다음과 같다.
	$$
		\Pr[\Fail \mid \neg\askR \land \Sbad \land \neg\askH] \le 2^{-\lm_1}.
	$$
	세 식을 결합하면, 다음과 같다.
	$$
		\Pr[\Fail \land \Cbad \mid \neg\askH] \leq 2^{-k_1} + (q_G + 1) \cdot 2^{-k_0}.
	$$

	다음으로, $\Pr[\Fail \land \neg\Cbad \mid \neg\askH]$를 계산하고 본 증명을
	마친다. 만약 $\neg \Cbad \wedge \askRS$가 성립한다면, 복호화
	시뮬레이션은 실패하지 않는다. 따라서 이 식은 아래와 같이 표현
	가능하다.
	\begin{align*}
		&\Pr[\Fail \land \neg\Cbad \mid \neg \askH] \\
		&= \underbrace{\Pr[\Fail \land \neg \Cbad \land \askRS \mid \neg \askH]}_{= 0}
		+ \Pr[\Fail \land \neg \Cbad \land \neg \askRS \mid \neg \askH] \\
		&= \Pr[\Fail \land \neg \Cbad \land \neg \askRS \mid \neg \askH].
	\end{align*}
	이제 $\neg \askH$를 잠시 고려하지 않고, 위 확률을 다음과 같이 계산한다.
	\begin{align*}
		&\Pr[\Fail \land \neg\Cbad \land \neg\askRS] \\
		&= \Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor \neg\askS)] \\
		&= \Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor (\neg\askS \land \askR))] \\
		&= \Pr[(\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR) \lor
		(\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askS \land \askR))] \\
		&\le \Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR]+
		\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askS \land \askR] \\
		&\le \Pr[\Fail \land \neg\Rbad \land \neg\askR]+
		\Pr[\Fail \land \askR \land \neg\askS \land \neg\Sbad] \\
		&\le \Pr[\Fail \land \neg\Rbad \mid \neg\askR]+
		\Pr[\Fail \land \askR \mid \neg\askS \land \neg\Sbad] \\
		&\le \Pr[\Fail \mid \neg\Rbad \land \neg\askR] +
		\Pr[\askR \mid \neg\askS \land \neg\Sbad].
	\end{align*}
	첫 번째 사건에서, $r$이 $\cO^{G}$에 대해 질의되지 않았고, 추가로 $r \ne
	r^*$인 사건을 고려하면, $G(r)$는 예측할 수 없으며, 따라서 \question{$[s \xor
	G(r)]_{\lm_1} = 0^{\lm_1}$이 될 확률}은 $2^{-\lm_1}$보다 작다. 그리고 두 번째
	사건에서, $H(s)$에 대한 정보 없이 $r$이 $\cO^{G}$에 대해 질의될 확률은 $q_G \cdot
	2^{-\lm_0}$보다 작다. \question{또한, 이 사건은 $\askH$와 독립적이므로} 다음이
	성립한다.
	$$
		\Pr[\Fail \wedge \neg \Cbad \wedge \neg \askRS \mid \neg \askH] 
		\leq 2^{-\lm_1} + q_G \cdot 2^{-\lm_0}.
	$$	
	그러므로, 다음과 같다.
	\begin{align*}
		\Pr[\Fail \mid \neg\askH]
		&= \Pr[\Fail \land \Cbad \mid \neg\askH] + \Pr[\Fail \land \neg\Cbad \mid \neg\askH] \\
		&\le (2^{-\lm_1} + (q_{G} + 1) \cdot 2^{-\lm_0}) + (2^{-\lm_1} + q_{G} \cdot 2^{-\lm_0}). \\
		&= \frac{2}{2^{\lm_1}} + \frac{2q_{G} + 1}{2^{\lm_0}}.
	\end{align*}
	이 시뮬레이터의 실행 시간은 가능한 모든 쌍에 대해 $\cF_{\pk}(\sigma, \tau)$를 계산하는 시간만 포함되며, 따라서 그 시간은 다음으로 상한된다.
	$$q_G \cdot q_H \cdot (T_{\cF} + \mathcal{O}(1)).$$
% 	함수 $\cF$는 일대일 대응이므로, $\sigma = s$는 유일하게 결정된다. 즉,
% 	$\delta, H_{\delta}$는 유일하게 결정된다. 마찬가지로 $\tau = t$도
% 	유일하게 결정되며, $\gamma, G_{\gamma}$도 마찬가지이다. 따라서 최대
% 	하나의 $\mu$만 선택 가능하다.
% 	% 위의 논의에서, G-List와 H-List는 함수 $G$와 $H$의 입력-출력 쌍을 나타낸다는 점을 유의해야 한다. 따라서 주어진 입력에 대해 최대 하나의 출력만 존재한다.
% 	공격자가 올바르게 암호문을 구성하여 질의한다면, 시뮬레이션은 정확한 출력을
% 	제공한다. 그러나 다른 모든 경우에는 $\REJECT$를 출력한다.

% 	성공 확률(Success Probability). 우리의 목표는 함수 $f$의 부분 영역
% 	단방향성(partial-domain one-wayness)에 대한 보안을 증명하는 것이므로, 우리는
% 	Fail 사건이 발생할 확률에만 관심이 있다. 이때, AskH가 발생하지 않았으며,
% 	이는 다른 사건들에 따라 나뉠 수 있다.
\end{proof}

% \subsection{증명: Success Probability of the Reduction}
% 이 절에서는 IND-CCA2 적대자의 이점에 대한 우리 감소 기법의 성공 확률을 분석한다.
% 감소 기법의 목표는, $c^* = f(s^*, t^*)$가 주어졌을 때 $s^*$를
% 얻는 것이다. 따라서 성공 확률은 감소 과정에서 AskH 사건이 발생할 확률에 의해
% 결정되며, 즉 다음과 같다:
% $$
% \Pr[\askH] \leq \text{Succ}^{\text{s-pd-OW}}(q_H, t')
% $$
% 여기서 $t'$는 감소 과정의 실행 시간이다. 먼저, 확률 $\Pr[\askH]$을 다음과 같이 분할한다.
% $$
% \Pr[\askH] = \Pr[\askH \land \Bad] + \Pr[\askH \land \neg \Bad].
% $$
% 먼저, 확률 $\Pr[\askH \land \Bad]$을 계산한다.
% \begin{align*}
% 	\Pr[\askH \wedge \Bad] 
% 	&= \Pr[\Bad] - \Pr[\neg \askH \wedge \Bad] \\
% 	&= \Pr[\Bad] - \Pr[\neg \askH \wedge (\Gbad \lor \Dbad)] \\
% 	&= \Pr[\Bad] - \Pr[(\neg\askH \wedge \Gbad) \lor (\neg\askH \land \Dbad)] \\
% 	&\ge \Pr[\Bad] - \Pr[\neg \askH \wedge \Gbad] - \Pr[\neg \askH \wedge \Dbad] \\
% 	&\ge \Pr[\Bad] - \Pr[\Gbad \mid \neg \askH] - \Pr[\Dbad \mid \neg \askH] \\
% 	&\ge \Pr[\Bad] - \Pr[\askG \mid \neg \askH] - \Pr[\Dbad \mid \neg \askH] \\
% \end{align*}

% \newpage
% \appendix
% \section{Proof of Equation 1}
% $\Pr[\Fail \land \neg\Cbad \land \neg\askRS]$은 $\Cbad$와 $\askRS$의 정의를
% 사용하여 다음과 같이 표현할 수 있다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor \neg\askS)].
% $$
% 임의의 사건 $X, Y$에 대해, $\Pr[\neg X \lor \neg Y] = \Pr[\neg X \lor (\neg Y
% \land X)]$이므로, 위 식은 다음과 같이 표현할 수 있다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor (\neg\askS \land \askR))].
% $$
% 이 식에서 분배법칙을 적용하면 다음과 같다.
% $$
% 	\Pr[(\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR) \lor
% 	(\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askS \land \askR))].
% $$
% $\Pr[X \lor Y] \le \Pr[X] + \Pr[Y]$이므로 위 식은 다음 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR]+
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askS \land \askR].
% $$
% 위 식에서 왼쪽 확률에서는 $\neg\Sbad$를 없애고, 오른쪽 확률에서는 $\neg\Rbad$를
% 없애, 아래 식으로 표현한다. $\Pr[X \land Y] \le \Pr[X]$이므로, 위 식은 아래 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\askR]+
% 	\Pr[\Fail \land \askR \land \neg\askS \land \neg\Sbad].
% $$
% $\Pr[X \land Y] \le \Pr[X \mid Y]$(혹은 $\le \Pr[Y \mid X]$)이므로, 위 식은 아래
% 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \mid \neg\askR]+
% 	\Pr[\Fail \land \askR \mid \neg\askS \land \neg\Sbad].
% $$
% 임의의 사건 $X, Y, Z$에 대해, $\Pr[X \land Y \mid Z] \le \Pr[X \mid Y \land Z]$, 그리고
% $\Pr[X \land Y \mid Z] \le \Pr[Y \mid Z]$이므로, 위 식은 아래 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \mid \neg\Rbad \land \neg\askR]+
% 	\Pr[\askR \mid \neg\askS \land \neg\Sbad].
% $$
% 위 내용을 종합하여 정리하면, 다음 식이 성랍한다는 것을 알 수 있다.
% $$
% 	\Pr[\Fail \land \neg\Cbad \land \neg\askRS] 
% 	\le \Pr[\Fail \mid \neg\Rbad \land \neg\askR]
% 	+ \Pr[\askR \mid \neg\askS \land \neg\Sbad].
% $$

% \newpage
% \section{번역}
% 분석을 시작하기 전에, 복호화 오라클 시뮬레이터는 복호화할 암호문 $c$와 암호화
% 오라클에서 얻은 도전 암호문 $c^*$, 그리고 무작위 오라클 $G$ 및 $H$와의
% 상호작용을 통해 생성된 G-List와 H-List를 입력으로 받는다는 점을 상기한다.

% 먼저, 시뮬레이션이 가능한 평문을 유일하게 정의할 수 있으며, 따라서 발견한 첫
% 번째 평문을 출력할 수 있음을 확인하자. 위의 정의에 따라, 여러 개의 쌍이 이러한
% 등식을 만족할 수 있다. 그러나 함수 $f$가 순열(permutation)이므로
% 일대일(one-to-one) 대응을 이루며, $\sigma = s$의 값은 유일하게 결정되므로,
% $\delta$와 $H_\delta$도 유일하게 정의된다. 마찬가지로, $\tau = t$도 유일하게
% 정의되며, $\gamma$와 $G_\gamma$ 역시 그러하다. 따라서, 최대 하나의 $\mu$만이
% 선택될 수 있다. 이후, $\mu$의 하위 비트가 $[\mu]_{k_1} = 0^{k_1}$인지 여부가
% 결정된다.

% 위의 논의에서, G-List와 H-List는 함수 $G$와 $H$의 입력-출력 쌍을 나타낸다는 점을
% 유의해야 한다. 따라서 주어진 입력에 대해 최대 하나의 출력만 존재한다.

% 적대자가 올바르게 암호문을 구성한 경우(즉, $r$이 $G$에 대해 질의되었으며, $s$가
% $H$에 대해 질의됨), 시뮬레이션은 정확한 출력을 제공한다. 그러나 그 외의 모든
% 경우에는 “Reject”를 출력하며, 이는 적대자가 무작위 오라클 $G$와 $H$에 대한 두
% 개의 질의 없이 유효한 암호문을 구성했을 수도 있기 때문이다.

% 성공 확률(Success Probability). 우리의 목표는 함수 $f$의 부분 영역
% 단방향성(partial-domain one-wayness)에 대한 보안을 증명하는 것이므로, 우리는
% Fail 사건이 발생할 확률에만 관심이 있다. 이때, AskH가 발생하지 않았으며,
% 이는 다른 사건들에 따라 나뉠 수 있다.

% 만약 $\neg \text{CBad} \wedge \text{AskRS}$가 성립한다면, 시뮬레이션은
% 완벽하며 실패하지 않는다. 따라서, 우리는 보완적인 사건들을 고려해야 한다.