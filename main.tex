\documentclass{article}

\title{RSA-OAEP IND-CCA2 증명}
\author{김동현(wlswudpdlf31@kookmin.ac.kr)}
\date{\today}

\usepackage{style}

\usepackage[normalem]{ulem}

\usepackage{xcolor}  % 색상 패키지

% 한국어 지원 패키지
\usepackage{kotex}

% Document setting
\usepackage{geometry}
\geometry{
	a4paper, 
	left=3cm, right=3cm, top=2cm, bottom=2cm, 
	includehead, includefoot}
	\usepackage{fancyhdr} % 머리말과 꼬리말 설정 
\usepackage{lastpage}
\pagestyle{fancy}
\fancyhf{} % 기존 머리말/꼬리말 초기화
\renewcommand{\headrulewidth}{0.4pt} % 머리말 선 두께
\fancyhead[L]{\leftmark} % 왼쪽 머리말
\fancyhead[R]{\rightmark} % 오른쪽 머리말
\renewcommand{\footrulewidth}{0.4pt}
\fancyfoot[L]{FDL}
\fancyfoot[R]{\thepage~/~\pageref{LastPage}} % 가운데 꼬리말에 페이지 번호 추가


% 수학 관련 패키지
\usepackage{amsmath, amssymb}
\usepackage{amsthm}
\usepackage{mathtools} % mathtools 패키지 필요
\newtheorem{theorem}{정리}
\newtheorem{lemma}{보조정리}
\theoremstyle{definition}
\newtheorem{memo}{메모}

\usepackage{setspace}
\setstretch{1.15} % 이 한 줄이면 끝!

% 이미지 관련 패키지
\usepackage{graphicx}

\usepackage{hyperref}

% TikZ 패키지 추가
\usepackage{tikz}

% Table package and setting
\usepackage{tcolorbox}
\usepackage{tabularx}
\usepackage{colortbl} % colortbl 패키지 추가
\newcolumntype{C}{>{\centering\arraybackslash}X}

\usepackage{booktabs}

\begin{document}
\maketitle
\tableofcontents

\newpage
\section{논문정보}

\begin{itemize}
	\item 제목: RSA-OAEP is Secure under the RSA Assumption
	\item 저자: Eiichiro Fujisaki1, Tatsuaki Okamoto, David Pointcheval, and Jacques Stern
	\item 년도: 2001년
	\item 초록: 최근 Victor Shoup은 적응적 선택 암호문 공격에 대한 OAEP의 보안성에 관한 널리
	받아들여진 결과에 틈이 있음을 지적하였다. 더욱이, 그는 기본 트랩도어 치환의
	단방향성만으로는 OAEP의 보안성을 증명할 수 없을 것으로 예상된다는 점을 보였다.
	본 논문은 OAEP의 보안성에 대한 또 다른 결과를 제시한다. 즉, 본 논문에서는 무작위
	오라클 모델에서, 기본 치환의 부분 영역 단방향성(partial-domain one-wayness)
	하에서, OAEP가 적응적 선택 암호문 공격에 대해 의미론적 보안성을 제공함을
	증명한다. 따라서, 이는 형식적으로 더 강한 가정을 사용한다. 그럼에도 불구하고,
	RSA 함수의 부분 영역 단방향성이 (전체 영역) 단방향성과 동치이므로, RSA-OAEP의
	보안성은 단순한 RSA 가정만으로도 증명될 수 있음을 알 수 있다. 다만, 그
	축소(reduction)는 타이트하지 않다.
\end{itemize}


% \section{확률론 기본 개념}

% 증명 과정에서 사건의 확률을 다루는 과정이 복잡하여 추가하였습니다. 먼저 가장 기본적인 공식부터 다룹니다.
% 사건 $X, Y, Z$에 대해 다음을 만족합니다.
% \begin{align}
% 	&\Pr[X \land Y] \le \Pr[X]. \\
% 	&\Pr[X \lor Y] \le \Pr[X] + \Pr[Y]. \\
% 	&\Pr[X \land (Y \land Z)] =  \Pr[(X \land Y) \land Z] = \Pr[X \land Y \land Z]. \\
% 	&\Pr[X \land (Y \lor Z)] = \Pr[(X \land Y) \lor (X \land Z)] \le \Pr[X \land Y] + \Pr[X \land Z]. \\
% 	&\Pr[\neg X \lor \neg Y] = \Pr[\neg X \lor (\neg Y \land X)] \\
% 	&a \\
% \end{align}

% \section{기호}

% \begin{itemize}
% 	\item $\sp$ 보안 매개변수
% 	\item $\pk$ 공개키
% 	\item $\sk$ 비밀키
% 	\item $(\pk, \sk) \gets \genkey(1^{\sp})$ 키 생성 알고리즘, 확률론적
% 	\item $\msg$ 메시지
% 	\item $\ct$ 암호문
% 	\item $\ct \gets \enc(\msg, \pk)$ 암호화 함수, 확률론적
% 	\item $\msg \gets \dec(\ct, \sk)$ 복호화 함수, 결정론적
% 	\item $\adv$ 공격자
% 	\item $\coin$ 랜덤 코인
% 	\item $\msgspace$ 메시지 공간
% 	\item $\coinspace$ 랜덤 코인 공간
% 	\item $\bit$ 0 또는 1
% 	\item $\hash, \gash$ 암호학적 해시 함수
% 	\item $\mlen$ 메시지 길이
% \end{itemize}

\newpage
\section{보안 개념}

% \subsection{$\owcpa$}

% \begin{tcolorbox}[colback=white]
% 	\centering
% 	\begin{tabularx}{\linewidth}{CcC}
% 		\underline{Challenger $\ch$} & $\xLeftrightarrow{\Exp^{\owcpa}_{\sch, \sp}}$ & \underline{Adversary $\adv$} \\
% 		\\
% 		$(\pk, \sk) \gets \genkey(1^{\sp})$ & $\xrightarrow{1^{\sp}, \pk}$ & \\
% 		\\
% 		$\msg^* \rgets \msgspace$ \\ $\ct^* \gets \enc_{\pk}(\msg^*)$ & $\xrightarrow{\ct^*}$ & \\
% 		\\
% 		Return $[\msg' \same \msg^*]$ & $\xleftarrow{\msg'}$ & $\adv$ chooses $\msg' \in \msgspace$ \\
%   \end{tabularx}
% \end{tcolorbox}

% \begin{align}
% 	\begin{split}
% 		\Adv^{\owcpa}_{\adv, \sch}(\sp)
% 		&= \Pr[\Exp^{\owcpa}_{\sch, \sp}(\adv) = 1] \\
% 		&= \underset{\msg^*}{\Pr}[
% 				(\pk, \sk) \gets \genkey(1^{\sp}): 
% 				\adv(\pk, \enc_{\pk}(m^*)) = \msg^*].
% 	\end{split}
% \end{align}

\subsection{OW trapdoor permutation}
트랩도어 치환 체계(Trapdoor permutation scheme) $\tdsch = (\genkey, \td, \itd)$를 다음과
같이 정의한다.
\begin{itemize}
	\item $\genkey(1^{\sp})$: 확률론적 키 생성 알고리즘으로, $1^{\sp}$를 입력
	받아 $(\pk, \sk)$를 생성한다.
	\item $\td_{\pk}(x)$: 결정론적 알고리즘으로, $\pk$와 $x \in \set{0, 1}^{\sp}$를 입력 받아
	$y \in \set{0 ,1}^{\sp}$를 출력한다.
	\item $\itd_{\sk}(y)$: 결정론적 알고리즘으로, $\sk$와 $y \in \set{0,
	1}^{\sp}$를 입력 받아 $x \in \set{0, 1}^{\sp}$를 출력한다.
	$\genkey(1^{\sp})$로 생성한 모든 $(\pk, \sk)$와 모든 $x \in \set{0,
	1}^{\sp}$에 대해, $\itd_{\sk}(\td_{\pk}(x)) = x$를 만족한다.
\end{itemize}
동작시간(Running time) $\rt$를 가지는 공격자 $\adv$와 트랩도어 치환 체계
$\tdsch$에 대한 일방향성(One-wayness) 실험 $\Exp^{\ow}_{\tdsch, \sp}(\adv; \rt)$을
다음과 같이 정의한다.
\begin{tcolorbox}[colback=white]
	\centering
	\begin{tabularx}{\linewidth}{CcC}
		\underline{Challenger $\ch$} & $\xLeftrightarrow{\Exp^{\ow}_{\tdsch, \sp}}$ & \underline{Adversary $\adv$} \\
		\\
		$(\pk, \sk) \rgets \genkey(1^{\sp})$ & & \\
		\\
		$x^* \rgets \set{0, 1}^{\sp}$ \\ $y^* \gets \td_{\pk}(x^*)$ & $\xrightarrow{1^{\sp}, \pk, y^*}$ & \\
		\\ 
		Return $[x' \same x^*]$ & $\xleftarrow{x'}$ & $\adv$ chooses $x' \in \xspace$ \\
  \end{tabularx}
\end{tcolorbox}

$\adv$의 능력치 $\Adv^{\ow}_{\adv;
\tdsch}(\sp, \rt)$를 다음과 같이 정의한다.
$$
	\Adv^{\ow}_{\tdsch, \sp}(\adv; \rt) := \Pr[\Exp^{\ow}_{\tdsch, \sp}(\adv; \rt) = 1].
$$
% 공격자 $\adv$의 능력치가 어떤 $\negl$에 대해 다음을 만족할 때, $\tdsch$가 $(\rt,
% \negl)$-일방향성을 가진다고 한다.
% $$
% 	\Adv^{\ow}_{\adv, \tdsch}(\sp, \rt) \le \negl.
% $$

\subsection{Partial-domain OW trapdoor permutation}

트랩도어 치환 $\tdsch = (\genkey, \td, \itd)$에서, $\td_{\pk}(x):\set{0, 1}^{\sp} \to
\set{0, 1}^{\sp}$를 다음과 같이 표현한다.
$$
	\td_{\pk}: \set{0, 1}^{\mlen + \sp_1} \times \set{0, 1}^{\sp_0} \to \set{0, 1}^{\mlen + \sp_1} \times \set{0, 1}^{\sp_0}.
$$
이때 $\sp = \mlen + \sp_0 + \sp_1$이다. 
\begin{memo}
	예를 들어, $x = s \parallel t$라고 할 때, $y \gets \td_{\pk}(x)$ 대신 $y
	\gets \td_{\pk}(s \parallel t)$로 표현할 수 있다.
\end{memo}
동작시간 $\rt$를 가지는 공격자 $\adv$와 트랩도어 함수 체계 $\tdsch$에 대한 부분
일방향성(Partial-domain one-wayness) 실험 $\Exp^{\owpd}_{\tdsch, \sp}(\adv;
\rt)$을 다음과 같이 정의한다.

\begin{tcolorbox}[colback=white]
	\centering
	\begin{tabularx}{\linewidth}{CcC}
		\underline{Challenger $\ch$} & $\xLeftrightarrow{\Exp^{\owpd}_{\tdsch, \sp}}$ & \underline{Adversary $\adv$} \\
		\\
		$(\pk, \sk) \rgets \genkey(1^{\sp})$ & & \\
		\\
		$(s^*, t^*) \rgets \set{0, 1}^{\mlen + \sp_1} \times \set{0, 1}^{\sp_0}$ \\ $y^* \gets \td_{\pk}(s^*, t^*)$ & $\xrightarrow{1^{\sp}, \pk, y^*}$ & \\
		\\
		Return $[s' \same s^*]$ & $\xleftarrow{s'}$ & $\adv$ chooses $s' \in \set{0, 1}^{\mlen + \sp_1}$ \\
  \end{tabularx}
\end{tcolorbox}

공격자 $\adv$의 능력치 $\Adv^{\owpd}_{\tdsch, \sp}(\adv; \rt)$를 다음과 같이 정의한다.
$$
	\Adv^{\owpd}_{\tdsch, \sp}(\adv; \rt) := \Pr[\Exp^{\owpd}_{\tdsch, \sp}(\adv; \rt) = 1].
$$
% 동작시간 $\rt$를 가지는 공격자 $\adv$의 능력치가 어떤 $\negl$에 대해 다음을
% 만족할 때, $\tdsch$가 $(\rt, \negl)$-부분 일방향성을 가진다고 한다.
% $$
% 	\Adv^{\owpd}_{\adv, \tdsch}(\sp, \rt) \le \negl.
% $$

\subsection{Set partial-domain OW trapdoor permutation}

동작시간 $\rt$를 가지고 $l$개의 원소를 출력하는 공격자 $\adv$와 트랩도어 함수
체계 $\tdsch$에 대한 집합 부분 일방향성(Set partial-domain one-wayness) 실험
$\Exp^{\owpds}_{\tdsch, \sp}(\adv; \rt, l)$을 다음과 같이 정의한다.
\begin{tcolorbox}[colback=white]
	\centering
	\begin{tabularx}{\linewidth}{CcC}
		\underline{Challenger $\ch$} & $\xLeftrightarrow{\Exp^{\owpds}_{\tdsch, \sp}}$ & \underline{Adversary $\adv$} \\
		\\
		$(\pk, \sk) \rgets \genkey(1^{\sp})$ & & \\
		\\
		$(s^*, t^*) \rgets \set{0, 1}^{\mlen + \sp_1} \times \set{0, 1}^{\sp_0}$ \\ $y^* \gets \td_{\pk}(s^*, t^*)$ & $\xrightarrow{1^{\sp}, \pk, y^*}$ & \\
		\\
		Return $[s^* \isin S']$ & $\xleftarrow{S'}$ & $\adv$ chooses $S' = \set{s_i \in \set{0, 1}^{\mlen + \sp_1}: 0 \le i \le l-1}$ \\
  \end{tabularx}
\end{tcolorbox}

공격자 $\adv$의 능력치 $\Adv^{\owpds}_{\tdsch, \sp}(\adv; \rt, l)$를 다음과 같이 정의한다.
$$
	\Adv^{\owpds}_{\tdsch, \sp}(\adv; \rt, l) := \Pr[\Exp^{\owpds}_{\tdsch, \sp}(\adv; \rt, l) = 1].
$$
% 동작시간 $\rt$를 가지는 공격자 $\adv$의 능력치가 어떤 $\negl$에 대해 다음을
% 만족할 때, $\tdsch$가 $(l, \rt, \negl)$-집합 부분 일방향성을 가진다고 한다.
% $$
% 	\Adv^{\owpds}_{\adv, \tdsch}(\sp, \rt, l) \le \negl.
% $$

\subsection{IND security against CCA2}

공개키 암호
체계(Public-key encryption scheme) $\sch = (\genkey, \enc, \dec)$를 다음과 같이
정의한다.
\begin{itemize}
	\item $\genkey(1^{\sp})$: 확률론적 키 생성 알고리즘으로, $1^{\sp}$를 입력
	받아 $(\pk, \sk)$를 생성한다.
	\item $\enc_{\pk}(\msg)$: 암호화 알고리즘으로, $\pk$와 $\msg \in
	\msgspace$를 입력 받아 $\ct \in \ctspace$를 출력한다. 확률론적 알고리즘으로,
	$\coin \rgets \coinspace$를 추가로 입력 받아 $\enc_{\pk}(\msg; \coin)$으로
	표현할 수도 있다.
	\item $\dec_{\sk}(\ct)$: 결정론적 복호화 알고리즘으로, $\sk$와 $\ct \in
	\ctspace$를 입력 받아 $\msg \in \msgspace$를 출력한다.
\end{itemize}

동작시간 $\rt$를 가지고 복호화 오라클에 $\qr$회 질의하는 공격자 $\adv$와 공개키
암호 체계 $\sch$에 대해, 선택 암호문 공격(Adaptive chosen ciphertext attack,
이하 CCA2)에 대한 구별불가능성(Indistinguishability)
실험 $\Exp^{\indcca}_{\sch, \sp}(\adv; \rt, \qr)$을 다음과 같이 정의한다.

\begin{tcolorbox}[colback=white]
	\centering
	\begin{tabularx}{\linewidth}{CcC}
		\underline{Challenger $\ch$} & $\xLeftrightarrow{\Exp^{\indcca}_{\sch, \sp}}$ & \underline{Adversary $\adv$} \\
		\\
		$(\pk, \sk) \gets \genkey(1^{\sp})$ & $\xrightarrow{1^{\sp}, \pk}$ & \\
		\\
		\multicolumn{3}{c}{\cellcolor{gray!20}$\orc^{\dec_{\sk}}$ Query Phase 1} \\
		\\ 
		& $\xleftarrow{\msg^*_0, \msg^*_1}$ & $\adv$ chooses $\msg^*_0, \msg^*_1 \in \msgspace$ such that $|\msg^*_0| = |\msg^*_1|$ and $\msg^*_0 \neq \msg^*_1$ \\
		\\
		$\bit \rgets \set{0, 1}, \coin^* \rgets \coinspace$ \\ $\ct^* \gets \enc_{\pk}(\msg^*_{\bit}; \coin^*)$ & $\xrightarrow{\ct^*}$ & \\
		\\
		\multicolumn{3}{c}{\cellcolor{gray!20}$\orc^{\dec_{\sk}}$ Query Phase 2} \\
		\\
		Return $[\bit' \same \bit]$ & $\xleftarrow{\bit'}$ & $\adv$ chooses $\bit' \in \set{0, 1}$ \\
  \end{tabularx}
\end{tcolorbox}

공격자 $\adv$의 능력치 $\Adv^{\indcca}_{\sch, \sp}(\adv; \rt, \qr)$를 다음과 같이 정의한다.
$$
	\Adv^{\indcca}_{\sch, \sp}(\adv; \rt, \qr) = 2 \cdot \Pr[\Exp^{\indcca}_{\sch, \sp}(\adv; \rt, \qr) = 1] - 1.
$$

\subsection{IND security against CCA2 in ROM}

동작시간 $\rt$를 가지고  복호화 오라클에 $\qr_{\dec}$회, 랜덤 오라클에
$\qr_{\hash}$회 질의하는 공격자 $\adv$와 공개키 암호 체계 $\sch$에 대해,
랜덤 오라클 모델(Random oracle model)에서의 CCA2에 대한 구별불가능성 실험
$\Exp^{\indccarom}_{\sch, \sp}(\adv; \rt, \qr_{\dec}, \qr_{\hash})$을 다음과
같이 정의한다.

\begin{tcolorbox}[colback=white]
	\centering
	\begin{tabularx}{\linewidth}{CcC}
		\underline{Challenger $\ch$} & $\xLeftrightarrow{\Exp^{\indccarom}_{\sch, \sp}}$ & \underline{Adversary $\adv$} \\
		\\
		$\orc_{\hash} \rgets \hashspace$ \\ $(\pk, \sk) \gets \genkey(1^{\sp})$ & $\xrightarrow{1^{\sp}, \pk}$ & \\
		\\
		\multicolumn{3}{c}{\cellcolor{gray!20}$\orc^{\hash}, \orc^{\dec_{\sk}}$ Query Phase 1} \\
		\\
		& $\xleftarrow{\msg^*_0, \msg^*_1}$ & $\adv$ chooses $\msg^*_0, \msg^*_1 \in \msgspace$ such that $|\msg^*_0| = |\msg^*_1|$ and $\msg^*_0 \neq \msg^*_1$ \\
		\\
		$\bit \rgets \set{0, 1}, \coin^* \rgets \coinspace$ \\ $\ct^* \gets \enc_{\pk}(\msg^*_{\bit}; \coin^*)$ & $\xrightarrow{\ct^*}$ & \\
		\\
		\multicolumn{3}{c}{\cellcolor{gray!20}$\orc^{\hash}, \orc^{\dec_{\sk}}$ Query Phase 2} \\
		\\
		Return $[\bit' \same \bit]$ & $\xleftarrow{\bit'}$ & $\adv$ chooses $\bit' \in \set{0, 1}$ \\
  \end{tabularx}
\end{tcolorbox}

공격자 $\adv$의 능력치 $\Adv^{\indccarom}_{\sch, \sp}(\adv; \rt, \qr_{\dec},
\qr_{\hash})$를 다음과 같이 정의한다.
$$
	\Adv^{\indccarom}_{\sch, \sp}(\adv; \rt, \qr_{\dec},
	\qr_{\hash}) = 2 \cdot \Pr[\Exp^{\indccarom}_{\sch, \sp}(\adv; \rt, \qr_{\dec},
	\qr_{\hash}) = 1] - 1.
$$

\newpage
\section{RSA-OAEP}
다음과 같은 트랩도어 치환 $\td$를 고려한다.
$$
	\td_{\pk}: \set{0, 1}^{\mlen + \sp_1} \times \set{0, 1}^{\sp_0} \to \set{0, 1}^{\mlen + \sp_1} \times \set{0, 1}^{\sp_0}.
$$
그리고 두 해시 함수 $H, G$를 다음과 같이 준비한다.
$$
	\hash: \set{0, 1}^{\sp_0} \to \set{0, 1}^{\sp - \sp_0} \quad
	\gash: \set{0, 1}^{\sp - \sp_0} \to \set{0, 1}^{\sp_0}.
$$
트랩토어 치환 체계 $\tdsch = (\genkey, \td, \itd)$를 포함하는 OAEP 변환
$(\genkey, \enc, \dec)$는 다음과 같이 동작한다.
\begin{itemize}
	\item $\genkey(1^{\sp})$: $(\pk, \sk)$를 생성한다. $\pk$는 이후 트랩도어 치환
	$\td$에서 사용하며, $\sk$는 $\itd$에서 사용한다.
	\item $\enc_{\pk}(\msg; \coin)$: $\msg \in \set{0, 1}^{\mlen}$과 $\coin
	\rgets \set{0, 1}^{\sp_0}$가 주어졌을 때, $s, t$를 다음과 같이 계산한다.
	$$
		s = (\msg \parallel 0^{\sp_1}) \xor \gash(\coin), \quad
		t = \coin \xor \hash(s).
	$$
	$s, t$를 계산하는 과정을 도식화하면 그림 \ref{fig:oaep}와 같다. 이후 암호문
	$\ct = \td_{\pk}(s, t)$를 출력한다.
  	\item $\dec_{\sk}(\ct)$: $(s,t) = \itd_{\sk}(\ct)$을 계산한 후, $r, M$을 다음과
  	같이 계산한다.
	$$
    	r = t \xor \hash(s) \quad M = s \xor \gash(\coin).
	$$
  	만약 $[M]_{\sp_1} = 0^{\sp_1}$이면 $[M]^{\mlen}$을 출력하고, 아니라면
  	“$\textsf{Reject}$”를 출력한다.
\end{itemize}

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\node (m0) at (0, 0) {$\msg \parallel 0^{\sp_1}$};
		\node (r) at (3, 0) {$\coin$};
		\node (g) at (1.5, -1) {$\gash$};
		\node (h) at (1.5, -2) {$\hash$};
		\node (s) at (0, -3) {$s$};
		\node (t) at (3, -3) {$t$};
		\node (xorh) at (0, -1) {$\xor$};
		\node (xorg) at (3, -2) {$\xor$};

		\draw[->] (r) |- (g);
		\draw[->] (r) -- (t);
		\draw[->] (m0) -- (s);
		\draw[->] (m0) |- (h);
		\draw[->] (g) -| (s);
		\draw[->] (h) -| (t);
	\end{tikzpicture}
	\caption{$\enc_{\pk}(\msg; \coin)$에서 $s, t$를 계산하는 과정}
	\label{fig:oaep}
\end{figure}

\section{증명}

\begin{tcolorbox}[colback=white]
	\begin{lemma}
		공격자 $\adv$를 OAEP 변환 $(\genkey, \enc, \dec)$에 대해 동작시간
		$\rt$를 가지고, 복호화 오라클 $\orc^{\dec}$와 랜덤 오라클 $\orc^{\hash},
		\orc^{\gash}$에 각각 $\qr_{\dec}, \qr_{\hash}, \qr_{\gash}$회 질의하는
		$\textsf{IND-CCA2}$ 공격자라 하자. 이때, 다음을 만족하는 $\owpds$
		공격자 $\bdv$가 존재한다.
		$$
			\Adv^{\owpds}_{\tdsch, \sp}(\bdv; \rt', \qr_{\hash})
		  	\ge \frac{\Adv^{\indcca}_{\sch, \sp}(\adv; \rt, \qr_{\dec}, \qr_{\hash}, \qr_{\gash})}{2}
		   	- \frac{2\qr_{\dec}\qr_{\gash} + \qr_{\dec} + \qr_{\gash}}{2^{\sp_0}}
		   	- \frac{2\qr_{\dec}}{2^{\sp_1}}.
		$$
	  	여기서, $\rt' \le \rt \cdot \qr_{\hash} \cdot \qr_{\gash} \cdot (\comp{\td} +
	   	\bigo(1))$이고, $\comp{\td}$는 트랩도어 치환 $\td$의 시간 복잡도를 의미한다.
	\end{lemma}
\end{tcolorbox}

% \begin{tcolorbox}
% 	우리는 $\text{Succ}^{\text{ow}}(\tau)$, (그리고 각각 $\text{Succ}^{\text{pd-ow}}(\tau)$ 및 $\text{Succ}^{\text{s-pd-ow}}(\ell, \tau)$)를 최대 성공 확률 $\text{Succ}^{\text{ow}}(\mathcal{A})$ (그리고 각각 $\text{Succ}^{\text{pd-ow}}(\mathcal{A})$ 및 $\text{Succ}^{\text{s-pd-ow}}(\mathcal{A})$)로 정의한다. 여기서 최대값은 실행 시간이 $\tau$ 이하로 제한된 모든 공격자(adversary)에 대해 계산된다.

% 세 번째 경우에서는 $\mathcal{A}$가 $\ell$개의 원소를 포함하는 집합을 출력한다는 추가적인 제한이 존재한다. 따라서, 모든 $\tau$ 및 $\ell \geq 1$에 대해 다음이 성립함이 분명하다.

% $$
% \text{Succ}^{\text{s-pd-ow}}(\ell, \tau) \geq \text{Succ}^{\text{pd-ow}}(\tau) \geq \text{Succ}^{\text{ow}}(\tau).
% $$

% 또한, 공격자가 반환한 집합에서 무작위로 원소를 선택함으로써 집합 부분 도메인 단방향성(Set Partial-Domain One-Wayness)을 깨뜨릴 수 있으며, 그 확률은 $\text{Succ}^{\text{s-pd-ow}}(\mathcal{A}) / \ell$이다. 이를 통해 다음의 부등식이 성립한다.

% $$
% \text{Succ}^{\text{pd-ow}}(\tau) \geq \text{Succ}^{\text{s-pd-ow}}(\ell, \tau) / \ell.
% $$

% 그러나 특정한 함수 $f$에 대해 보다 효율적인 환원이 존재할 수도 있다. 또한, 어떤 경우에는 세 가지 문제 모두 다항식적으로 동등할 수 있다. 이는 RSA 치환(RSA permutation)의 경우에 해당하며, 따라서 이에 대한 결과는 6장에서 다룬다.
% \end{tcolorbox}

% 우리는 보조정리 2를 세 단계로 증명한다. 첫 번째 단계에서는 $\indcca$ 적대자
% $\adv$를 부분 도메인 일방성(partial-domain one-wayness) $f$를 깨뜨리는 알고리즘
% $\bdv$로 환원하는 과정을 제시한다. 현재의 증명에서는 원본 논문 [3]에서와 같은
% 전체 도메인 일방성(full-domain one-wayness)이 아니라, 부분 도메인 일방성
% 하에서의 보안성에만 관심을 둔다. 두 번째 단계에서는 이 환원에서 사용된 복호화
% 오라클 시뮬레이션이 부분 도메인 일방성 하에서 압도적인 확률로 올바르게 동작함을
% 보인다. 이 부분은 원본 증명 [3]과 다르며, 최근 발견된 오류 [15]를 수정한다.
% 마지막으로, 우리는 복호화 오라클 시뮬레이션에 대한 위에서 언급한 분석을 포함하여
% 전체적인 환원의 성공 확률을 분석한다.

% 이 첫 번째 부분에서는 환원이 어떻게 작동하는지를 다시 살펴본다. $\adv$를
% $(\genkey, \enc, \dec)$의 $\indcca$ 공격자로 가정하자. 시간 제한 $\rt$ 내에서,
% $\adv$는 복호화 오라클에 대해 $\qr_{\dec}$개의 질의를 하고, 무작위 오라클 $\hash,
% \gash$에 대해 각각 $\qr_{\hash}, \qr_{\gash}$개의 질의를 수행하며, 특정 확률
% $\negl$보다 높은 능력치로 올바른 평문을 구별해낸다. 이제 환원 $\bdv$을 설명한다.

\subsection{증명: Reduction and simulation}

\begin{tcolorbox}[colback=white]
	\centering
	\begin{tabularx}{\linewidth}{CcCcC}
		\underline{Challenger $\ch$} & $\xLeftrightarrow{\Exp^{\owpds}_{\tdsch, \sp}}$ & \underline{Adversary $\bdv$} & $\xLeftrightarrow{\Exp^{\indccarom}_{\sch, \sp}}$ & \underline{Adversary $\adv$} \\
		\\
		$(\pk, \sk) \gets \genkey(1^{\sp})$ & &  &  & \\
		\\
		$(s^*, t^*) \rgets \set{0, 1}^{\sp - \sp_0} \times \set{0, 1}^{\sp_0}$ \newline $\ct^* \gets \td_{\pk}(s^*, t^*)$ & $\xrightarrow{1^{\sp}, \pk, \ct^*}$ & & & \\
		\\
		 & & $\orcl_{\hash}, \orcl_{\gash} \gets \set{}, \set{}$ & $\xrightarrow{1^{\sp}, \pk}$ & \\
		\\
		 & & \multicolumn{3}{c}{\cellcolor{gray!20}$\orc^{\dec_{\sk}}, \orc^{\hash}, \orc^{\gash}$ Query Phase 1} \\
		\\
		& & & $\xleftarrow{\msg^*_0, \msg^*_1}$ & $\adv$ chooses $\msg^*_0, \msg^*_1 \in \msgspace$ such that $|\msg^*_0| = |\msg^*_1|$ and $\msg^*_0 \neq \msg^*_1$ \\
		\\
		 & & $\bit \rgets \set{0, 1}$ & $\xrightarrow{\ct^*}$ & \\
		\\
		 & & \multicolumn{3}{c}{\cellcolor{gray!20}$\orc^{\dec_{\sk}}, \orc^{\hash}, \orc^{\gash}$ Query Phase 2} \\
		\\
		Return $s^* \isin S'$ & $\xleftarrow{S'}$ & $\bdv$ chooses $S' = \set{s \in \orcl_{\hash}}$ & $\xleftarrow{\bit'}$ & $\adv$ chooses $\bit' \in \set{0, 1}$ \\
  \end{tabularx}
\end{tcolorbox}

% 이 실험에서 세 개의 오라클을 $\bdv$가 처리하기 때문에, 다음을 고려해야한다.
% \begin{itemize}
% 	\item 공격자 $\adv$의 질의에 대해서, 오라클은 유효한 응답을 해야 한다. $\adv$가
% 	오라클이 잘못된 응답을 하고 있다는 것을 감지해서는 안된다.
% 	\item 오라클이 기대하는 확률분포와 일관되어야 한다. 일관되지 않으면 $\adv$가
% 	이상을 감지할 수 있다.
% 	\item 오라클 응답은 일관되어야 한다.
% 	\item 복호화 오라클은 $\bdv$가 비밀키를 모름에도 수행할 수 있어야 한다.
% \end{itemize}

% \begin{memo}
% 	오라클을 현실적으로 모델링할 때는 다음을 고려해야 한다.
% 	\begin{itemize}
% 		\item 응답이 유효해야 한다.
% 		\item 질의한 상대방이 오라클에 기대하는 확률 분포와 동일해야 한다. 예를
% 			  들어, 랜덤 오라클에 질의했다고 한다면, 모델링한 오라클은
% 			  균등분포를 따라야 한다.
% 		\item 복호화 오라클의 경우, 트랩도어 없이 모델링해야 한다.
% 	\end{itemize}
% \end{memo}

먼저, 공격자 $\bdv$가 $\orc^{\hash}$를 동작시키는 시뮬레이션을 정의한다. 공격자
$\adv$가 랜덤 오라클 $\orc^{\hash}$에 $\delta$를 질의했다고 하자. 공격자
$\bdv$는 다음과 같이 $\hash_{\delta}$를 응답한다.
\begin{enumerate}
	\item 만약 $\delta$가 $\orcl_{\hash}$에 있다면, $\delta$에 대응하는
	$\hash_\delta$를 응답한다. (즉, $(\delta, \hash_{\delta}) \in \orcl_{\hash}$)
	\item 만약 $\delta$가 $\orcl_{\hash}$에 없다면, $\hash_{\delta} \rgets
	\set{0 ,1}^{\sp_0}$을 수행한 후 $\hash_{\delta}$를 응답한다. 이후
	$\orcl_{\hash} \gets \orcl_{\hash} \cap (\delta, \hash_{\delta})$를
	수행한다.
\end{enumerate}

다음으로, 공격자 $\bdv$가 $\orc^{\gash}$를 동작시키는 시뮬레이션을 정의한다.
공격자 $\adv$가 랜덤 오라클 $\orc^{\gash}$에 $\gamma$를 질의했다고 하자. 공격자
$\bdv$는 다음과 같이 $\gash_{\gamma}$를 응답한다.
\begin{enumerate}
	\item 만약 $\gamma$가 $\orcl_{\gash}$에 있다면, $\gamma$에 대응하는
	$\gash_{\gamma}$를 응답한다.
	\item 만약 $\gamma$가 $\orcl_{\gash}$에 없다면, 다음 과정을 진행한다.
	\begin{enumerate}
		\item 어떤 $(\delta, \hash_{\delta}) \in \orcl_{\hash}$에 대해, 만약
		$c^* = \td_{\pk}(\delta, \gamma \xor \hash_{\delta})$라면, 우리는 여전히
		$\gash$를 올바르게 시뮬레이션할 수 있다. 이 때 응답은 $\gash_{\gamma}
		\gets \delta \xor (\msg_{\bit} \parallel 0^{\sp_1})$이다. $\delta =
		s^\star$이고 $s^\star$가 균등하게 분포하므로 $G_\gamma$는 균등 분포된
		값이 된다. 
		\item 모든 $(\delta, \hash_{\delta}) \in \orcl_{\hash}$에 대해, 만약
		$c^* \neq \td_{\pk}(\delta, \gamma \xor \hash_{\delta})$라면,
		$\gash_{\gamma} \rgets \set{0 ,1}^{n + \sp_1}$를 수행한다.
		\item $\gash_{\gamma}$를 응답한 후, $\orcl_{\gash} \gets \orcl_{\gash}
		\cap (\gamma, \gash_{\gamma})$를 수행한다.
	\end{enumerate}
\end{enumerate}

% \begin{tcolorbox}
% 	\centering
% 	\begin{tabularx}{\linewidth}{CcC}
% 		\underline{Adversary $\bdv$} & & \underline{Adversary $\adv$} \\
% 		\\
% 		& $\xleftarrow{\gamma}$ & $\adv$ Chooses $\gamma \in \set{0, 1}$ \\
% 		If $\gamma \in \orcl_{\gash}$, then $\gash_{\gamma} \gets \orcl_{\gash}$ & & \\
% 		Otherwise, & & \\
% 	\end{tabularx}
% \end{tcolorbox}

마지막으로, 공격자 $\bdv$가 $\orc^{\dec}$를 동작시키는 시뮬레이션을 정의한다. 공격자
$\adv$가 랜덤 오라클 $\orc^{\dec}$에 $\ct = \td_{\pk}(s, t)$를 질의했다고 하자. 공격자
$\bdv$는 다음과 같이 응답한다.
\begin{enumerate}
	\item $\orcl_{\gash}$의 질의 응답 쌍 $(\gamma, G_\gamma) \in \orcl_{\gash}$
	및 $\orcl_{\hash}$의 $(\delta, H_\delta) \in \orcl_{\hash}$를 조회하고, 각
	리스트에서 선택된 쌍에 대해 다음과 같이 정의한다.
	$$
		\sigma = \delta, 
		\quad \tau = \gamma \oplus H_\delta, 
		\quad \mu = G_\gamma \oplus \delta.
	$$
	만약 $\ct = \td_{\pk}(\sigma, \tau)$이면서 $[\mu]_{\sp_1} = 0^{\sp_1}$라면,
	$[\mu]^{\mlen}$을 응답한다.
	\item 그 외에는 $\reject$를 응답한다.
\end{enumerate}

\subsection{증명: 사건 정의}

\newcommand{\askG}{\textsf{AskG}}
\newcommand{\askH}{\textsf{AskH}}
\newcommand{\Gbad}{\textsf{GBad}}
\newcommand{\Dbad}{\textsf{DBad}}
\newcommand{\Bad}{\textsf{Bad}}
\newcommand{\Sbad}{\textsf{SBad}}
\newcommand{\Rbad}{\textsf{RBad}}
\newcommand{\Cbad}{\textsf{CBad}}
\newcommand{\Fail}{\textsf{Fail}}
\newcommand{\askR}{\textsf{AskR}}
\newcommand{\askS}{\textsf{AskS}}
\newcommand{\askRS}{\textsf{AskRS}}

\begin{table}[h]
	\centering
	\caption{오라클 관련 사건 정의}
	\vspace{10pt}
	\renewcommand{\arraystretch}{1.15}
	\begin{tabularx}{\textwidth}{p{1cm}X}
	\toprule
	$\askG$ & $\coin^*$가 $\orc^{\gash}$에 질의되었을(has been asked) 사건. \\
	$\askH$ & $s^*$가 $\orc^{\hash}$에 질의되었을 사건. \\
	$\Gbad$ & $\orc^{\gash}$에 $\coin^*$를 질의했지만, $\orc^{\gash}$의 응답이
	$s^* \xor (\msg_{\bit} \parallel 0^{\sk})$가 아닌 사건. $\Gbad$가 발생하면,
	$\askG$도 발생한다. \\ % $\Gbad$는 랜덤 오라클을 \textit{불완전(imperfect)}하게 만드는 유일한 사건이다.
	$\Dbad$ & \sout{CPA 시나리오에서 복호화가 실패하는 사건.} \\
	$\Bad$ & \sout{$\Gbad \vee \Dbad$.} \\
	\bottomrule
	\end{tabularx}
\end{table}

공격자 $\adv$는 복호화 오라클 $\orc^{\dec}$에 암호문 $\ct = \td_{\pk}(s, t)$를
질의할 수 있다. 질의한 암호문 $\ct$와 관련된 사건을 다음 표와 같이 정의한다.
\begin{table}[h]
	\centering
	\caption{복호화 시뮬레이션 관련 사건 정의}
	\vspace{10pt}
	\renewcommand{\arraystretch}{1.15}
	\begin{tabularx}{\textwidth}{p{1cm}X}
	\toprule
	$\Sbad$ & $s = s^*$인 사건. \\
	$\Rbad$ & $\coin = \coin^*$인 사건. 즉, $\hash(s) \xor t =  \hash(s^*) \xor
	t^*$인 사건. \\
	$\Cbad$ & $\Sbad \vee \Rbad.$ \\
	$\askR$ & $r$이 $\orc^{\gash}$에 질의되었을 사건. 즉, $\hash(s) \xor t$이 질의되었을 사건 \\
	$\askS$ & $s$가 $\orc^{\hash}$에 질의되었을 사건. \\
	$\askRS$ & $\askR \land \askS$ \\
	$\Fail$ & 복호화 오라클이 질의 $\ct$에 대해 잘못 응답하는 사건. $i$번째 질의
	$\ct_i$에 대해서는 $\Fail_i$로 나타낸다. 여기서 $i = 1, \cdots,
	\qr_{\dec}$이다. \question{어떤 $i$에 대해서도 $\Fail_i$의 확률을 균등하게
	평가(evaluate)할 수 있으므로, 여기서는 사용하지 않는다. $\Fail$ 사건은 평문
	추출기(plaintext extractor)가 실제 복호화 오라클에서는 허용될 암호문을
	거부하는 경우로 제한된다. 실제로, 추출기가 암호문을 허용하는 순간, 해당
	암호문이 유효하며 출력 평문과 일치함을 알 수 있다.} \\
	\bottomrule
	\end{tabularx}
\end{table}

\subsection{증명: Analysis of the Decryption Oracle Simulation}

% 우리는 다음과 같은 주장을 하며, 이는 새로운 계산적 가정을 기반으로 이전 증명
% [3]을 수정하는 것이다. 보다 정확히 말하면, 평문 인식성(plaintext-awareness)의
% 수정된 정의 [1]로 인해 고려해야 할 추가적인 경우들이 순열 $f$의 부분 영역
% 단방향성(partial-domain one-wayness) 하에서 매우 낮은 확률로 발생함을 보인다.

\begin{tcolorbox}[colback=white]
	\begin{lemma}
		$s^\star$가 $\orc^{\hash}$에 질의되지 않았을 때, $\orc^{\dec}$는 질의된
		암호문 $c$ $(c \neq c^\star)$에 대해 출력을 정확히 생성할 수 있으며, 이
		확률은 다음보다 크거나 같다.
		$$
			1 - \left( \frac{2}{2^{k_1}} + \frac{2q_G + 1}{2^{k_0}} \right).
		$$
		또한, 시간 제한 $t' \leq q_G \cdot q_H \cdot (T_{\td} + \mathcal{O}(1))$ 내에서 이를 수행할 수 있다.
	\end{lemma}
\end{tcolorbox}

\begin{proof}
	본 증명에서는 다음이 참임을 보인다.
	$$
		\Pr[\Fail \mid \neg\askH] \le  \frac{2}{2^{\sp_1}} + \frac{2\qr_{\gash} + 1}{2^{\sp_0}}.
	$$
	$\Pr[\Fail \mid \neg\askH]$는 다음과 같이 표현 가능하다.
	$$
		\Pr[\Fail \land \Cbad \mid \neg\askH]
		+ \Pr[\Fail \land \neg\Cbad \mid \neg\askH].
	$$
	본 증명에서는 먼저 $\Pr[\Fail \land \Cbad \mid \neg\askH]$를 구한다. $\Cbad
	= \Sbad \lor (\Rbad \land \neg\Sbad)$를 이용하여, 이 확률을 다음과 같이 표현한다.
	\begin{align*}
		&\Pr[\Fail \land \Cbad \mid \neg\askH] \\
		&= \Pr[\Fail \land (\Sbad \lor (\Rbad \land \neg\Sbad)) \mid \neg\askH] \\
		&= \Pr[(\Fail \land \Sbad) \lor (\Fail \land \Rbad \land \neg\Sbad) \mid \neg\askH] \\
		&\le \Pr[\Fail \land \Sbad \mid \neg\askH] + \Pr[\Fail \land \Rbad \land \neg\Sbad \mid \neg\askH] \\
		&\le \Pr[\Fail \land \Sbad \mid \neg\askH] + \Pr[\Rbad \land \neg\Sbad \mid \neg\askH] \\
		&\le \Pr[\Fail \mid \Sbad \land \neg\askH] + \Pr[\Rbad \mid \neg\Sbad \land \neg\askH]. \\
		&= \Pr[\Fail \land \askR \mid \Sbad \land \neg\askH] + \Pr[\Fail \land \neg\askR \mid \Sbad \land \neg\askH] + \Pr[\Rbad \mid \neg\Sbad \land \neg\askH]. \\
		&\le \Pr[\askR \mid \Sbad \land \neg\askH] + \Pr[\Fail \mid \neg\askR \land \Sbad \land \neg\askH] + \Pr[\Rbad \mid \neg\Sbad \land \neg\askH].
	\end{align*}
	세 번째 사건은 $s \ne s^\star$이고 공격자 $\adv$가 $s^\star$에 대해
	$\orc^{\hash}$에 질의하지 않았을 때 $\Rbad$가 발생함을 의미한다. $s^\star$가
	$\orc^H$에 질의되지 않았고 $s \ne s^\star$일 때, $H(s^\star)$는 예측
	불가능(unpredictable)하며 $H(s)$뿐 아니라 $t$, $t^\star$와도 독립적이다.
	이때 RBad 사건, $H(s^\star) = H(s) \oplus t \oplus t^\star$ 는 최대
	$2^{-\sp_0}$의 확률로 발생한다. 즉, 다음과 같다.
	$$
		\Pr[\Rbad \mid \neg\Sbad \land \neg\askH] \le 2^{-\sp_0}.
	$$
	첫 번째 사건은 $s = s^\star$이며 $\hash(s^\star)$는 예측 불가능할 때, $r$이
	$\orc^{\gash}$에 대해 질의되었을 사건을 의미한다. 이때, $H(s)$ 또한 예측
	불가능하다. 즉, $r = H(s) \xor t$가 예측 불가능하므로, $r$이 $\orc^G$에
	질의되었을 확률은 최대 $q_G \cdot 2^{-\lambda_0}$이다. 즉, 다음과 같다.
	$$
		\Pr[\askR \mid \Sbad \land \neg\askH] \le \qr_{\gash} \cdot 2^{-\sp_0}.
	$$
	두 번째 사건은 복호화 시뮬레이션에서 $H(s)$는 예측 불가능하고 $r$은 $\orc^G$에
	질의되지 않았을 때, 유효한 암호문 $\ct$를 거부하는 경우이다. \question{페이스텔
	네트워크(Feistel network)의 일대일 성질에 따라 $s = s^\star$이면 $r \ne
	r^\star$이고, 따라서 $G(r)$는 예측 불가능하다.} 그러므로 이 경우 중복 조건은
	$2^{-\sp_1}$보다 큰 확률로 성립할 수 없다. 즉, 다음과 같다.
	$$
		\Pr[\Fail \mid \neg\askR \land \Sbad \land \neg\askH] \le 2^{-\sp_1}.
	$$
	세 식을 결합하면, 다음과 같다.
	$$
		\Pr[\Fail \land \Cbad \mid \neg\askH] \leq 2^{-k_1} + (q_G + 1) \cdot 2^{-k_0}.
	$$

	다음으로, $\Pr[\Fail \land \neg\Cbad \mid \neg\askH]$를 계산하고 본 증명을
	마친다. 만약 $\neg \Cbad \wedge \askRS$가 성립한다면, 복호화
	시뮬레이션은 실패하지 않는다. 따라서 이 식은 아래와 같이 표현
	가능하다.
	\begin{align*}
		&\Pr[\Fail \land \neg\Cbad \mid \neg \askH] \\
		&= \underbrace{\Pr[\Fail \land \neg \Cbad \land \askRS \mid \neg \askH]}_{= 0}
		+ \Pr[\Fail \land \neg \Cbad \land \neg \askRS \mid \neg \askH] \\
		&= \Pr[\Fail \land \neg \Cbad \land \neg \askRS \mid \neg \askH].
	\end{align*}
	이제 $\neg \askH$를 잠시 고려하지 않고, 위 확률을 다음과 같이 계산한다.
	\begin{align*}
		&\Pr[\Fail \land \neg\Cbad \land \neg\askRS] \\
		&= \Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor \neg\askS)] \\
		&= \Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor (\neg\askS \land \askR))] \\
		&= \Pr[(\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR) \lor
		(\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askS \land \askR))] \\
		&\le \Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR]+
		\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askS \land \askR] \\
		&\le \Pr[\Fail \land \neg\Rbad \land \neg\askR]+
		\Pr[\Fail \land \askR \land \neg\askS \land \neg\Sbad] \\
		&\le \Pr[\Fail \land \neg\Rbad \mid \neg\askR]+
		\Pr[\Fail \land \askR \mid \neg\askS \land \neg\Sbad] \\
		&\le \Pr[\Fail \mid \neg\Rbad \land \neg\askR] +
		\Pr[\askR \mid \neg\askS \land \neg\Sbad].
	\end{align*}
	첫 번째 사건에서, $r$이 $\orc^{\gash}$에 대해 질의되지 않았고, 추가로 $r \ne
	r^*$인 사건을 고려하면, $G(r)$는 예측할 수 없으며, 따라서 \question{$[s \oplus
	G(r)]_{\sp_1} = 0^{\sp_1}$이 될 확률}은 $2^{-\sp_1}$보다 작다. 그리고 두 번째
	사건에서, $H(s)$에 대한 정보 없이 $r$이 $\orc^{\gash}$에 대해 질의될 확률은 $q_G \cdot
	2^{-\sp_0}$보다 작다. \question{또한, 이 사건은 $\askH$와 독립적이므로} 다음이
	성립한다.
	$$
		\Pr[\Fail \wedge \neg \Cbad \wedge \neg \askRS \mid \neg \askH] 
		\leq 2^{-\sp_1} + q_G \cdot 2^{-\sp_0}.
	$$	
	그러므로, 다음과 같다.
	\begin{align*}
		\Pr[\Fail \mid \neg\askH]
		&= \Pr[\Fail \land \Cbad \mid \neg\askH] + \Pr[\Fail \land \neg\Cbad \mid \neg\askH] \\
		&\le (2^{-\sp_1} + (\qr_{\gash} + 1) \cdot 2^{-\sp_0}) + (2^{-\sp_1} + \qr_{\gash} \cdot 2^{-\sp_0}). \\
		&= \frac{2}{2^{\sp_1}} + \frac{2\qr_{\gash} + 1}{2^{\sp_0}}.
	\end{align*}
	이 시뮬레이터의 실행 시간은 가능한 모든 쌍에 대해 $\td_{\pk}(\sigma, \tau)$를 계산하는 시간만 포함되며, 따라서 그 시간은 다음으로 상한된다.
	$$q_G \cdot q_H \cdot (T_{\td} + \mathcal{O}(1)).$$
% 	함수 $\td$는 일대일 대응이므로, $\sigma = s$는 유일하게 결정된다. 즉,
% 	$\delta, \hash_{\delta}$는 유일하게 결정된다. 마찬가지로 $\tau = t$도
% 	유일하게 결정되며, $\gamma, \gash_{\gamma}$도 마찬가지이다. 따라서 최대
% 	하나의 $\mu$만 선택 가능하다.
% 	% 위의 논의에서, G-List와 H-List는 함수 $G$와 $H$의 입력-출력 쌍을 나타낸다는 점을 유의해야 한다. 따라서 주어진 입력에 대해 최대 하나의 출력만 존재한다.
% 	공격자가 올바르게 암호문을 구성하여 질의한다면, 시뮬레이션은 정확한 출력을
% 	제공한다. 그러나 다른 모든 경우에는 $\reject$를 출력한다.

% 	성공 확률(Success Probability). 우리의 목표는 함수 $f$의 부분 영역
% 	단방향성(partial-domain one-wayness)에 대한 보안을 증명하는 것이므로, 우리는
% 	Fail 사건이 발생할 확률에만 관심이 있다. 이때, AskH가 발생하지 않았으며,
% 	이는 다른 사건들에 따라 나뉠 수 있다.
\end{proof}

% \subsection{증명: Success Probability of the Reduction}
% 이 절에서는 IND-CCA2 적대자의 이점에 대한 우리 감소 기법의 성공 확률을 분석한다.
% 감소 기법의 목표는, $c^\star = f(s^\star, t^\star)$가 주어졌을 때 $s^\star$를
% 얻는 것이다. 따라서 성공 확률은 감소 과정에서 AskH 사건이 발생할 확률에 의해
% 결정되며, 즉 다음과 같다:
% $$
% \Pr[\askH] \leq \text{Succ}^{\text{s-pd-ow}}(q_H, t')
% $$
% 여기서 $t'$는 감소 과정의 실행 시간이다. 먼저, 확률 $\Pr[\askH]$을 다음과 같이 분할한다.
% $$
% \Pr[\askH] = \Pr[\askH \land \Bad] + \Pr[\askH \land \neg \Bad].
% $$
% 먼저, 확률 $\Pr[\askH \land \Bad]$을 계산한다.
% \begin{align*}
% 	\Pr[\askH \wedge \Bad] 
% 	&= \Pr[\Bad] - \Pr[\neg \askH \wedge \Bad] \\
% 	&= \Pr[\Bad] - \Pr[\neg \askH \wedge (\Gbad \lor \Dbad)] \\
% 	&= \Pr[\Bad] - \Pr[(\neg\askH \wedge \Gbad) \lor (\neg\askH \land \Dbad)] \\
% 	&\ge \Pr[\Bad] - \Pr[\neg \askH \wedge \Gbad] - \Pr[\neg \askH \wedge \Dbad] \\
% 	&\ge \Pr[\Bad] - \Pr[\Gbad \mid \neg \askH] - \Pr[\Dbad \mid \neg \askH] \\
% 	&\ge \Pr[\Bad] - \Pr[\askG \mid \neg \askH] - \Pr[\Dbad \mid \neg \askH] \\
% \end{align*}

% \newpage
% \appendix
% \section{Proof of Equation 1}
% $\Pr[\Fail \land \neg\Cbad \land \neg\askRS]$은 $\Cbad$와 $\askRS$의 정의를
% 사용하여 다음과 같이 표현할 수 있다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor \neg\askS)].
% $$
% 임의의 사건 $X, Y$에 대해, $\Pr[\neg X \lor \neg Y] = \Pr[\neg X \lor (\neg Y
% \land X)]$이므로, 위 식은 다음과 같이 표현할 수 있다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askR \lor (\neg\askS \land \askR))].
% $$
% 이 식에서 분배법칙을 적용하면 다음과 같다.
% $$
% 	\Pr[(\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR) \lor
% 	(\Fail \land \neg\Rbad \land \neg\Sbad \land (\neg\askS \land \askR))].
% $$
% $\Pr[X \lor Y] \le \Pr[X] + \Pr[Y]$이므로 위 식은 다음 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askR]+
% 	\Pr[\Fail \land \neg\Rbad \land \neg\Sbad \land \neg\askS \land \askR].
% $$
% 위 식에서 왼쪽 확률에서는 $\neg\Sbad$를 없애고, 오른쪽 확률에서는 $\neg\Rbad$를
% 없애, 아래 식으로 표현한다. $\Pr[X \land Y] \le \Pr[X]$이므로, 위 식은 아래 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \land \neg\askR]+
% 	\Pr[\Fail \land \askR \land \neg\askS \land \neg\Sbad].
% $$
% $\Pr[X \land Y] \le \Pr[X \mid Y]$(혹은 $\le \Pr[Y \mid X]$)이므로, 위 식은 아래
% 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \land \neg\Rbad \mid \neg\askR]+
% 	\Pr[\Fail \land \askR \mid \neg\askS \land \neg\Sbad].
% $$
% 임의의 사건 $X, Y, Z$에 대해, $\Pr[X \land Y \mid Z] \le \Pr[X \mid Y \land Z]$, 그리고
% $\Pr[X \land Y \mid Z] \le \Pr[Y \mid Z]$이므로, 위 식은 아래 식보다 작거나 같다.
% $$
% 	\Pr[\Fail \mid \neg\Rbad \land \neg\askR]+
% 	\Pr[\askR \mid \neg\askS \land \neg\Sbad].
% $$
% 위 내용을 종합하여 정리하면, 다음 식이 성랍한다는 것을 알 수 있다.
% $$
% 	\Pr[\Fail \land \neg\Cbad \land \neg\askRS] 
% 	\le \Pr[\Fail \mid \neg\Rbad \land \neg\askR]
% 	+ \Pr[\askR \mid \neg\askS \land \neg\Sbad].
% $$

% \newpage
% \section{번역}
% 분석을 시작하기 전에, 복호화 오라클 시뮬레이터는 복호화할 암호문 $c$와 암호화
% 오라클에서 얻은 도전 암호문 $c^\star$, 그리고 무작위 오라클 $G$ 및 $H$와의
% 상호작용을 통해 생성된 G-List와 H-List를 입력으로 받는다는 점을 상기한다.

% 먼저, 시뮬레이션이 가능한 평문을 유일하게 정의할 수 있으며, 따라서 발견한 첫
% 번째 평문을 출력할 수 있음을 확인하자. 위의 정의에 따라, 여러 개의 쌍이 이러한
% 등식을 만족할 수 있다. 그러나 함수 $f$가 순열(permutation)이므로
% 일대일(one-to-one) 대응을 이루며, $\sigma = s$의 값은 유일하게 결정되므로,
% $\delta$와 $H_\delta$도 유일하게 정의된다. 마찬가지로, $\tau = t$도 유일하게
% 정의되며, $\gamma$와 $G_\gamma$ 역시 그러하다. 따라서, 최대 하나의 $\mu$만이
% 선택될 수 있다. 이후, $\mu$의 하위 비트가 $[\mu]_{k_1} = 0^{k_1}$인지 여부가
% 결정된다.

% 위의 논의에서, G-List와 H-List는 함수 $G$와 $H$의 입력-출력 쌍을 나타낸다는 점을
% 유의해야 한다. 따라서 주어진 입력에 대해 최대 하나의 출력만 존재한다.

% 적대자가 올바르게 암호문을 구성한 경우(즉, $r$이 $G$에 대해 질의되었으며, $s$가
% $H$에 대해 질의됨), 시뮬레이션은 정확한 출력을 제공한다. 그러나 그 외의 모든
% 경우에는 “Reject”를 출력하며, 이는 적대자가 무작위 오라클 $G$와 $H$에 대한 두
% 개의 질의 없이 유효한 암호문을 구성했을 수도 있기 때문이다.

% 성공 확률(Success Probability). 우리의 목표는 함수 $f$의 부분 영역
% 단방향성(partial-domain one-wayness)에 대한 보안을 증명하는 것이므로, 우리는
% Fail 사건이 발생할 확률에만 관심이 있다. 이때, AskH가 발생하지 않았으며,
% 이는 다른 사건들에 따라 나뉠 수 있다.

% 만약 $\neg \text{CBad} \wedge \text{AskRS}$가 성립한다면, 시뮬레이션은
% 완벽하며 실패하지 않는다. 따라서, 우리는 보완적인 사건들을 고려해야 한다.

\end{document}
